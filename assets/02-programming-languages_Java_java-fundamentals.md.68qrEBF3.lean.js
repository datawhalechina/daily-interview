import{_ as l,c as d,o as i,ag as t,j as o,a}from"./chunks/framework.DT5BmYxR.js";const q=JSON.parse('{"title":"Java 基础","description":"","frontmatter":{},"headers":[],"relativePath":"02-programming-languages/Java/java-fundamentals.md","filePath":"02-programming-languages/Java/java-fundamentals.md"}'),c={name:"02-programming-languages/Java/java-fundamentals.md"},s={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},r={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"8.346ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 3689 1000","aria-hidden":"true"},n={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},h={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"5.495ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 2429 1000","aria-hidden":"true"};function p(u,e,g,k,b,m){return i(),d("div",null,[e[15]||(e[15]=t("",8)),o("p",null,[e[4]||(e[4]=a("首先和",-1)),e[5]||(e[5]=o("code",null,"hashcode",-1)),e[6]||(e[6]=a("碰撞次数的泊松分布有关，主要是为了寻找一种时间和空间的平衡。在负载因子0.75（HashMap默认）的情况下，单个",-1)),e[7]||(e[7]=o("code",null,"hash",-1)),e[8]||(e[8]=a("槽内元素个数为8的概率小于百万分之一，将7作为一个分水岭，等于7时不做转换，大于等于8才转红黑树，小于等于6才转链表。链表中元素个数为8时的概率已经非常小，再多的就更少了，所以原作者在选择链表元素个数时选择了8，是根据概率统计而选择的。红黑树中的",-1)),e[9]||(e[9]=o("code",null,"TreeNode",-1)),e[10]||(e[10]=a("是链表中的",-1)),e[11]||(e[11]=o("code",null,"Node",-1)),e[12]||(e[12]=a("所占空间的2倍，虽然红黑树的查找效率为",-1)),o("mjx-container",s,[(i(),d("svg",r,[...e[0]||(e[0]=[t("",1)])])),e[1]||(e[1]=o("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[o("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[o("mi",null,"O"),o("mo",{stretchy:"false"},"("),o("mi",null,"l"),o("mi",null,"o"),o("mi",null,"g"),o("mi",null,"N"),o("mo",{stretchy:"false"},")")])],-1))]),e[13]||(e[13]=a("，要优于链表的",-1)),o("mjx-container",n,[(i(),d("svg",h,[...e[2]||(e[2]=[t("",1)])])),e[3]||(e[3]=o("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[o("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[o("mi",null,"O"),o("mo",{stretchy:"false"},"("),o("mi",null,"N"),o("mo",{stretchy:"false"},")")])],-1))]),e[14]||(e[14]=a("，但是当链表长度比较小的时候，即使全部遍历，时间复杂度也不会太高。所以，要寻找一种时间和空间的平衡，即在链表长度达到一个阈值之后再转换为红黑树",-1))]),e[16]||(e[16]=t("",212))])}const x=l(c,[["render",p]]);export{q as __pageData,x as default};
