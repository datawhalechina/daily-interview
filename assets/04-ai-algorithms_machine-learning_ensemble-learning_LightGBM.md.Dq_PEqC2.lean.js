import{_ as i,c as n,o as r,ag as l,j as t,a as e}from"./chunks/framework.DT5BmYxR.js";const o="/daily-interview/images/LightGBM.png",V=JSON.parse('{"title":"LightGBM面试题","description":"","frontmatter":{},"headers":[],"relativePath":"04-ai-algorithms/machine-learning/ensemble-learning/LightGBM.md","filePath":"04-ai-algorithms/machine-learning/ensemble-learning/LightGBM.md"}'),s={name:"04-ai-algorithms/machine-learning/ensemble-learning/LightGBM.md"},m={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},T={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.798ex"},xmlns:"http://www.w3.org/2000/svg",width:"3.886ex",height:"2.764ex",role:"img",focusable:"false",viewBox:"0 -868.9 1717.7 1221.7","aria-hidden":"true"},Q={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},d={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"5.909ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 2611.7 1000","aria-hidden":"true"},f={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},p={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"5.909ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 2611.7 1000","aria-hidden":"true"},h={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},g={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"7.04ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 3111.7 1000","aria-hidden":"true"},x={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},u={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"5.909ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 2611.7 1000","aria-hidden":"true"},w={tabindex:"0",class:"MathJax",jax:"SVG",display:"true",style:{direction:"ltr",display:"block","text-align":"center",margin:"1em 0",position:"relative"}},c={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-2.059ex"},xmlns:"http://www.w3.org/2000/svg",width:"47.594ex",height:"5.285ex",role:"img",focusable:"false",viewBox:"0 -1426 21036.4 2336","aria-hidden":"true"};function v(b,a,y,M,_,k){return r(),n("div",null,[a[25]||(a[25]=l("",18)),t("p",null,[a[2]||(a[2]=e("GOSS算法从减少样本的角度出发，排除大部分小梯度的样本，仅用剩下的样本计算信息增益，它是一种在减少数据量和保证精度上平衡的算法。与此同时，未了不改变数据的总体分布，GOSS对要进行分裂的特征按照绝对值大小进行排序，选取最大的a个数据，在剩下梯度小的数据中选取b个，这b个数据乘以权重",-1)),t("mjx-container",m,[(r(),n("svg",T,[...a[0]||(a[0]=[l("",1)])])),a[1]||(a[1]=t("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[t("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[t("mfrac",null,[t("mrow",null,[t("mn",null,"1"),t("mo",null,"−"),t("mi",null,"a")]),t("mi",null,"b")])])],-1))]),a[3]||(a[3]=e(",最后使用这a+b个数据计算信息增益。",-1))]),a[26]||(a[26]=t("h2",{id:"_5-介绍互斥特征捆绑算法-efb",tabindex:"-1"},[e("5. 介绍互斥特征捆绑算法(EFB)？ "),t("a",{class:"header-anchor",href:"#_5-介绍互斥特征捆绑算法-efb","aria-label":'Permalink to "5. 介绍互斥特征捆绑算法(EFB)？"'},"​")],-1)),a[27]||(a[27]=t("p",null,"互斥特征捆绑算法（Exclusive Feature Bundling, EFB）指出如果将一些特征进行融合绑定，则可以降低特征数量。 LightGBM的EFB算法将这个问题转化为图着色的问题来求解，将所有的特征视为图的各个顶点，将不是相互独立的特征用一条边连接起来，边的权重就是两个相连接的特征的总冲突值，这样需要绑定的特征就是在图着色问题中要涂上同一种颜色的那些点（特征）。另外，算法可以允许一小部分的冲突，我们可以得到更少的绑定特征，进一步提高计算效率。",-1)),a[28]||(a[28]=t("h2",{id:"_6-特征之间如何捆绑",tabindex:"-1"},[e("6. 特征之间如何捆绑？ "),t("a",{class:"header-anchor",href:"#_6-特征之间如何捆绑","aria-label":'Permalink to "6. 特征之间如何捆绑？"'},"​")],-1)),t("p",null,[a[12]||(a[12]=e("比如，我们在bundle中绑定了两个特征A和B，A特征的原始取值为区间 ",-1)),t("mjx-container",Q,[(r(),n("svg",d,[...a[4]||(a[4]=[l("",1)])])),a[5]||(a[5]=t("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[t("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[t("mo",{stretchy:"false"},"["),t("mn",null,"0"),t("mo",null,","),t("mn",null,"10"),t("mo",{stretchy:"false"},")")])],-1))]),a[13]||(a[13]=e("，B特征的原始取值为区间",-1)),t("mjx-container",f,[(r(),n("svg",p,[...a[6]||(a[6]=[l("",1)])])),a[7]||(a[7]=t("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[t("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[t("mo",{stretchy:"false"},"["),t("mn",null,"0"),t("mo",null,","),t("mn",null,"20"),t("mo",{stretchy:"false"},")")])],-1))]),a[14]||(a[14]=e("，我们可以在B特征的取值上加一个偏置常量10，将其取值范围变为",-1)),t("mjx-container",h,[(r(),n("svg",g,[...a[8]||(a[8]=[l("",1)])])),a[9]||(a[9]=t("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[t("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[t("mo",{stretchy:"false"},"["),t("mn",null,"10"),t("mo",null,","),t("mn",null,"30"),t("mo",{stretchy:"false"},")")])],-1))]),a[15]||(a[15]=e("，绑定后的特征取值范围为",-1)),t("mjx-container",x,[(r(),n("svg",u,[...a[10]||(a[10]=[l("",1)])])),a[11]||(a[11]=t("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[t("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[t("mo",{stretchy:"false"},"["),t("mn",null,"0"),t("mo",null,","),t("mn",null,"30"),t("mo",{stretchy:"false"},")")])],-1))])]),a[29]||(a[29]=t("h2",{id:"_7-lightgbm是怎么支持类别特征",tabindex:"-1"},[e("7. LightGBM是怎么支持类别特征？ "),t("a",{class:"header-anchor",href:"#_7-lightgbm是怎么支持类别特征","aria-label":'Permalink to "7. LightGBM是怎么支持类别特征？"'},"​")],-1)),t("ul",null,[a[21]||(a[21]=t("li",null,[t("p",null,"离散特征建立直方图的过程"),t("p",null,"统计该特征下每一种离散值出现的次数，并从高到低排序，并过滤掉出现次数较少的特征值, 然后为每一个特征值，建立一个bin容器。")],-1)),t("li",null,[a[20]||(a[20]=t("p",null,"计算分裂阈值的过程",-1)),t("ul",null,[a[19]||(a[19]=t("li",null,[t("p",null,"先看该特征下划分出的bin容器的个数，如果bin容器的数量小于4，直接使用one vs other方式, 逐个扫描每一个bin容器，找出最佳分裂点;")],-1)),t("li",null,[a[18]||(a[18]=t("p",null,"对于bin容器较多的情况, 先进行过滤，只让子集合较大的bin容器参加划分阈值计算, 对每一个符合条件的bin容器进行公式计算",-1)),t("mjx-container",w,[(r(),n("svg",c,[...a[16]||(a[16]=[l("",1)])])),a[17]||(a[17]=t("mjx-assistive-mml",{unselectable:"on",display:"block",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",overflow:"hidden",width:"100%"}},[t("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[t("mfrac",null,[t("mrow",null,[t("mi",{mathvariant:"normal"},"该"),t("mi",null,"b"),t("mi",null,"i"),t("mi",null,"n"),t("mi",{mathvariant:"normal"},"容"),t("mi",{mathvariant:"normal"},"器"),t("mi",{mathvariant:"normal"},"下"),t("mi",{mathvariant:"normal"},"所"),t("mi",{mathvariant:"normal"},"有"),t("mi",{mathvariant:"normal"},"样"),t("mi",{mathvariant:"normal"},"本"),t("mi",{mathvariant:"normal"},"的"),t("mi",{mathvariant:"normal"},"一"),t("mi",{mathvariant:"normal"},"阶"),t("mi",{mathvariant:"normal"},"梯"),t("mi",{mathvariant:"normal"},"度"),t("mi",{mathvariant:"normal"},"之"),t("mi",{mathvariant:"normal"},"和")]),t("mrow",null,[t("mi",{mathvariant:"normal"},"该"),t("mi",null,"b"),t("mi",null,"i"),t("mi",null,"n"),t("mi",{mathvariant:"normal"},"容"),t("mi",{mathvariant:"normal"},"器"),t("mi",{mathvariant:"normal"},"下"),t("mi",{mathvariant:"normal"},"所"),t("mi",{mathvariant:"normal"},"有"),t("mi",{mathvariant:"normal"},"样"),t("mi",{mathvariant:"normal"},"本"),t("mi",{mathvariant:"normal"},"的"),t("mi",{mathvariant:"normal"},"二"),t("mi",{mathvariant:"normal"},"阶"),t("mi",{mathvariant:"normal"},"梯"),t("mi",{mathvariant:"normal"},"度"),t("mi",{mathvariant:"normal"},"之"),t("mi",{mathvariant:"normal"},"和")])]),t("mo",null,"+"),t("mi",{mathvariant:"normal"},"正"),t("mi",{mathvariant:"normal"},"则"),t("mi",{mathvariant:"normal"},"项")])],-1))])])])]),a[22]||(a[22]=t("li",null,[t("p",null,[t("strong",null,'这里为什么不是label的均值呢？其实"label的均值"只是为了便于理解，只针对了学习一棵树且是回归问题的情况， 这时候一阶导数是Y, 二阶导数是1'),e(")，得到一个值，根据该值对bin容器从小到大进行排序，然后分从左到右、从右到左进行搜索，得到最优分裂阈值。但是有一点，没有搜索所有的bin容器，而是设定了一个搜索bin容器数量的上限值，程序中设定是32，即参数max_num_cat。")])],-1)),a[23]||(a[23]=t("li",null,[t("p",null,"LightGBM中对离散特征实行的是many vs many 策略，这32个bin中最优划分的阈值的左边或者右边所有的bin容器就是一个many集合，而其他的bin容器就是另一个many集合。")],-1)),a[24]||(a[24]=t("li",null,[t("p",null,"对于连续特征，划分阈值只有一个，对于离散值可能会有多个划分阈值，每一个划分阈值对应着一个bin容器编号，当使用离散特征进行分裂时，只要数据样本对应的bin容器编号在这些阈值对应的bin集合之中，这条数据就加入分裂后的左子树，否则加入分裂后的右子树。")],-1))]),a[30]||(a[30]=l("",13))])}const H=i(s,[["render",v]]);export{V as __pageData,H as default};
