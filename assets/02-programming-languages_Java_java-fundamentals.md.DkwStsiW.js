import{_ as l,c as t,o as i,ag as d,j as a,a as o}from"./chunks/framework.DT5BmYxR.js";const b=JSON.parse('{"title":"Java 基础","description":"","frontmatter":{},"headers":[],"relativePath":"02-programming-languages/Java/java-fundamentals.md","filePath":"02-programming-languages/Java/java-fundamentals.md"}'),c={name:"02-programming-languages/Java/java-fundamentals.md"},r={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},n={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"21.495ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 9501 1000","aria-hidden":"true"};function s(h,e,p,u,k,m){return i(),t("div",null,[e[12]||(e[12]=d('<h1 id="java-基础" tabindex="-1">Java 基础 <a class="header-anchor" href="#java-基础" aria-label="Permalink to &quot;Java 基础&quot;">​</a></h1><h2 id="知识体系" tabindex="-1">知识体系 <a class="header-anchor" href="#知识体系" aria-label="Permalink to &quot;知识体系&quot;">​</a></h2><h2 id="questions" tabindex="-1">Questions <a class="header-anchor" href="#questions" aria-label="Permalink to &quot;Questions&quot;">​</a></h2><h3 id="_1-hashmap-1-8�-7的区�" tabindex="-1">1. <code>HashMap</code> 1.8�?.7的区�? <a class="header-anchor" href="#_1-hashmap-1-8�-7的区�" aria-label="Permalink to &quot;1. `HashMap` 1.8�?.7的区�?&quot;">​</a></h3><table tabindex="0"><thead><tr><th style="text-align:center;"></th><th style="text-align:center;">1.7</th><th style="text-align:center;">1.8</th></tr></thead><tbody><tr><td style="text-align:center;">底层结构</td><td style="text-align:center;">数组+链表</td><td style="text-align:center;">数组+链表/红黑�?</td></tr><tr><td style="text-align:center;">插入方式</td><td style="text-align:center;">头插�?</td><td style="text-align:center;">尾插�?</td></tr><tr><td style="text-align:center;">计算hash�?</td><td style="text-align:center;">4次位运算+5次异或运�?</td><td style="text-align:center;">1次位运算+1次异或运�?</td></tr><tr><td style="text-align:center;">扩容、插�?</td><td style="text-align:center;">先扩容再插入</td><td style="text-align:center;">先插入再扩容</td></tr><tr><td style="text-align:center;">扩容后位置计�?</td><td style="text-align:center;">重新hash</td><td style="text-align:center;">原位置或原位�?旧容�?</td></tr></tbody></table><h4 id="_1-扩容因子默认为什么是0-75" tabindex="-1">(1) 扩容因子默认为什么是0.75 <a class="header-anchor" href="#_1-扩容因子默认为什么是0-75" aria-label="Permalink to &quot;(1) 扩容因子默认为什么是0.75&quot;">​</a></h4><p>如果扩容因子过高，空间利用率提高但是哈希冲突概率增加；如果扩容因子过低，会造成频繁扩容，哈希冲突概率降低，但是空间利用率变低。选择0.75是基于泊松分布，是时间和空间成本上寻求的一种折中选择</p><h4 id="_2-为什么链表长度为8要转化为红黑�" tabindex="-1">(2)为什么链表长度为8要转化为红黑�? <a class="header-anchor" href="#_2-为什么链表长度为8要转化为红黑�" aria-label="Permalink to &quot;(2)为什么链表长度为8要转化为红黑�?&quot;">​</a></h4>',8)),a("p",null,[e[2]||(e[2]=o("首先和",-1)),e[3]||(e[3]=a("code",null,"hashcode",-1)),e[4]||(e[4]=o("碰撞次数的泊松分布有关，主要是为了寻找一种时间和空间的平衡。在负载因子0.75（HashMap默认）的情况下，单个",-1)),e[5]||(e[5]=a("code",null,"hash",-1)),e[6]||(e[6]=o("槽内元素个数�?的概率小于百万分之一，将7作为一个分水岭，等�?时不做转换，大于等于8才转红黑树，小于等于6才转链表。链表中元素个数�?时的概率已经非常小，再多的就更少了，所以原作者在选择链表元素个数时选择�?，是根据概率统计而选择的。红黑树中的",-1)),e[7]||(e[7]=a("code",null,"TreeNode",-1)),e[8]||(e[8]=o("是链表中的",-1)),e[9]||(e[9]=a("code",null,"Node",-1)),e[10]||(e[10]=o("所占空间的2倍，虽然红黑树的查找效率�?O(logN)",-1)),a("mjx-container",r,[(i(),t("svg",n,[...e[0]||(e[0]=[d('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">，</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">要</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">优</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">于</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">链</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">表</text></g><g data-mml-node="mi" transform="translate(6000,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">�</text></g><g data-mml-node="mo" transform="translate(6600,0)"><path data-c="3F" d="M226 668Q190 668 162 656T124 632L114 621Q116 621 119 620T130 616T145 607T157 591T162 567Q162 544 147 529T109 514T71 528T55 566Q55 625 100 661T199 704Q201 704 210 704T224 705H228Q281 705 320 692T378 656T407 612T416 567Q416 503 361 462Q267 395 247 303Q242 279 242 241V224Q242 205 239 202T222 198T205 201T202 218V249Q204 320 220 371T255 445T292 491T315 537Q317 546 317 574V587Q317 604 315 615T304 640T277 661T226 668ZM162 61Q162 89 180 105T224 121Q247 119 264 104T281 61Q281 31 264 16T222 1Q197 1 180 16T162 61Z" style="stroke-width:3;"></path></g><g data-mml-node="mi" transform="translate(7072,0)"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z" style="stroke-width:3;"></path></g><g data-mml-node="mo" transform="translate(7835,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z" style="stroke-width:3;"></path></g><g data-mml-node="mi" transform="translate(8224,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z" style="stroke-width:3;"></path></g><g data-mml-node="mo" transform="translate(9112,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z" style="stroke-width:3;"></path></g></g></g>',1)])])),e[1]||(e[1]=a("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("mi",null,"，"),a("mi",{mathvariant:"normal"},"要"),a("mi",{mathvariant:"normal"},"优"),a("mi",{mathvariant:"normal"},"于"),a("mi",{mathvariant:"normal"},"链"),a("mi",{mathvariant:"normal"},"表"),a("mi",null,"�"),a("mo",null,"?"),a("mi",null,"O"),a("mo",{stretchy:"false"},"("),a("mi",null,"N"),a("mo",{stretchy:"false"},")")])],-1))]),e[11]||(e[11]=o("，但是当链表长度比较小的时候，即使全部遍历，时间复杂度也不会太高。所以，要寻找一种时间和空间的平衡，即在链表长度达到一个阈值之后再转换为红黑树",-1))]),e[13]||(e[13]=d('<h3 id="_2-string-、stringbuffer-、stringbuilder-的区�" tabindex="-1">2. <code>String</code> 、<code>StringBuffer</code> 、<code>StringBuilder</code> 的区�? <a class="header-anchor" href="#_2-string-、stringbuffer-、stringbuilder-的区�" aria-label="Permalink to &quot;2. `String` 、`StringBuffer` 、`StringBuilder` 的区�?&quot;">​</a></h3><table tabindex="0"><thead><tr><th style="text-align:center;"></th><th style="text-align:center;">是否可变</th><th style="text-align:center;">线程是否安全</th><th style="text-align:center;">性能</th></tr></thead><tbody><tr><td style="text-align:center;">String</td><td style="text-align:center;">不可�?</td><td style="text-align:center;">安全</td><td style="text-align:center;">�?</td></tr><tr><td style="text-align:center;">StringBuilder</td><td style="text-align:center;">可变</td><td style="text-align:center;">不安�?</td><td style="text-align:center;">�?</td></tr><tr><td style="text-align:center;">StringBuffer</td><td style="text-align:center;">可变</td><td style="text-align:center;">安全</td><td style="text-align:center;">较高</td></tr></tbody></table><h3 id="_3-强引用、软引用、弱引用、虚引用的区�" tabindex="-1">3.强引用、软引用、弱引用、虚引用的区�? <a class="header-anchor" href="#_3-强引用、软引用、弱引用、虚引用的区�" aria-label="Permalink to &quot;3.强引用、软引用、弱引用、虚引用的区�?&quot;">​</a></h3><ul><li><p>**强引�?*：如果一个对象具有强引用，垃圾回收器绝不会回收它。当内存空间不足时，JVM 宁愿抛出OOM错误，使程序异常终止�?</p></li><li><p>**软引�?*：如果内存空间足够，垃圾回收器就不会回收它。如果内存空间不足了，就会回收这些对象的内存，只要垃圾回收器没有回收它，该对象就可以被程序使�?</p></li><li><p>**弱引�?*：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内�?</p></li><li><p>**虚引�?*：在任何时候都可能被垃圾回收器回收</p></li></ul><h3 id="_4-�-equals-区别" tabindex="-1">4.<code>==</code>�?<code>equals</code> 区别 <a class="header-anchor" href="#_4-�-equals-区别" aria-label="Permalink to &quot;4.`==`�?`equals` 区别&quot;">​</a></h3><ul><li>==：如果是基本数据类型，比较的是值，如果是引用数据类型，比较的是地址</li><li><code>equals</code>：继承自 <code>Object</code> 类，具体实现时可以覆盖父类的实现。如果没有复写，则和 == 一样，比较地址；如果复写了则根据复写的判断方式</li></ul><h3 id="_5-object-类的-hashcode-方法的作�" tabindex="-1">5.<code>Object</code> 类的 <code>hashCode</code> 方法的作�? <a class="header-anchor" href="#_5-object-类的-hashcode-方法的作�" aria-label="Permalink to &quot;5.`Object` 类的 `hashCode` 方法的作�?&quot;">​</a></h3><p><code>hashCode </code>的哈希码主要作用是给散列表快速确定索引的，通过哈希码先判断对象是否有可能相同（因为相同的对象哈希码也一定相同），再去用 equals() 做进一步的比较，这样可以大大减少使�?<code>equals()</code>比较的次�?</p><h1 id="java并发" tabindex="-1">Java并发 <a class="header-anchor" href="#java并发" aria-label="Permalink to &quot;Java并发&quot;">​</a></h1><h2 id="知识体系-1" tabindex="-1">知识体系 <a class="header-anchor" href="#知识体系-1" aria-label="Permalink to &quot;知识体系&quot;">​</a></h2><h2 id="questions-1" tabindex="-1">Questions <a class="header-anchor" href="#questions-1" aria-label="Permalink to &quot;Questions&quot;">​</a></h2><h3 id="_1-线性池了解吗-参数有哪些-任务到达线程池的过程-线程池的大小如何设置" tabindex="-1">1.线性池了解吗？参数有哪些？任务到达线程池的过程？线程池的大小如何设置？ <a class="header-anchor" href="#_1-线性池了解吗-参数有哪些-任务到达线程池的过程-线程池的大小如何设置" aria-label="Permalink to &quot;1.线性池了解吗？参数有哪些？任务到达线程池的过程？线程池的大小如何设置？&quot;">​</a></h3><h4 id="线程池参�" tabindex="-1">线程池参�? <a class="header-anchor" href="#线程池参�" aria-label="Permalink to &quot;线程池参�?&quot;">​</a></h4><table tabindex="0"><thead><tr><th style="text-align:center;">参数</th><th style="text-align:center;">作用</th></tr></thead><tbody><tr><td style="text-align:center;">corePoolSize</td><td style="text-align:center;">核心线程池大�?</td></tr><tr><td style="text-align:center;">maximumPoolSize</td><td style="text-align:center;">最大线程池大小</td></tr><tr><td style="text-align:center;">keepAliveTime</td><td style="text-align:center;">线程池中超过 corePoolSize 数目的空闲线程最大存活时间；可以allowCoreThreadTimeOut(true) 使得核心线程有效时间</td></tr><tr><td style="text-align:center;">TimeUnit</td><td style="text-align:center;">keepAliveTime 时间单位</td></tr><tr><td style="text-align:center;">workQueue</td><td style="text-align:center;">阻塞任务队列</td></tr><tr><td style="text-align:center;">threadFactory</td><td style="text-align:center;">新建线程工厂</td></tr><tr><td style="text-align:center;">RejectedExecutionHandler</td><td style="text-align:center;">拒绝策略。当提交任务数超�?maxmumPoolSize+workQueue 之和时，任务会交给RejectedExecutionHandler 来处�?</td></tr></tbody></table><h4 id="线程处理任务过程" tabindex="-1">线程处理任务过程 <a class="header-anchor" href="#线程处理任务过程" aria-label="Permalink to &quot;线程处理任务过程&quot;">​</a></h4><ul><li>当线程池小于 <code>corePoolSize</code>，新提交任务将创建一个新线程执行任务，即使此时线程池中存在空闲线�?</li><li>当线程池达到 <code>corePoolSize</code> 时，新提交任务将被放�?<code>workQueue </code> 中，等待线程池中任务调度执行</li><li>�?<code>workQueue</code> 已满，且 <code>maximumPoolSize</code> 大于 <code>corePoolSize</code> 时，新提交任务会创建新线程执行任�?</li><li>当提交任务数超过 <code>maximumPoolSize</code> 时，新提交任务由 <code>RejectedExecutionHandler</code> 处理</li><li>当线程池中超�?<code>corePoolSize</code> 线程，空闲时间达�?<code>keepAliveTime</code> 时，关闭空闲线程</li></ul><h4 id="线程池的大小设置" tabindex="-1">线程池的大小设置 <a class="header-anchor" href="#线程池的大小设置" aria-label="Permalink to &quot;线程池的大小设置&quot;">​</a></h4><ul><li><p><code>CPU</code> 密集�?</p><ul><li><code>CPU</code> 密集的意思是该任务需要大量的运算，而没有阻塞，<code>CPU</code> 一直全速运�?</li><li><code>CPU</code> 密集型任务尽可能的少的线程数量，一般为 <code>CPU</code> 核数 +1 个线程的线程�?</li></ul></li><li><p><code>IO</code> 密集�?</p><ul><li>由于 <code>IO</code> 密集型任务线程并不是一直在执行任务，可以多分配一点线程数，如 <code>CPU * 2</code></li><li>也可以使用公式：<code>CPU</code> 核数 / (1 - 阻塞系数)；其中阻塞系数在 0.8 �?0.9 之间</li></ul></li></ul><h3 id="_2-java乐观锁机制-cas思想-缺点-是否原子性" tabindex="-1">2.<code>Java</code>乐观锁机制，<code>CAS</code>思想？缺点？是否原子性？ <a class="header-anchor" href="#_2-java乐观锁机制-cas思想-缺点-是否原子性" aria-label="Permalink to &quot;2.`Java`乐观锁机制，`CAS`思想？缺点？是否原子性？&quot;">​</a></h3><h4 id="java乐观锁机�" tabindex="-1"><code>Java</code>乐观锁机�? <a class="header-anchor" href="#java乐观锁机�" aria-label="Permalink to &quot;`Java`乐观锁机�?&quot;">​</a></h4><p>乐观锁体现的是悲观锁的反面。它是一种积极的思想，它总是认为数据是不会被修改的，所以是不会对数据上锁的。但是乐观锁在更新的时候会去判断数据是否被更新过。乐观锁的实现方案一般有两种（版本号机制�?<code>CAS</code>）。乐观锁适用于读多写少的场景，这样可以提高系统的并发量。在 <code>Java</code> �?<code>java.util.concurrent.atomic</code>下的原子变量类就是使用了乐观锁的一种实现方�?<code>CAS</code> 实现的�?</p><p>乐观锁，大多是基于数据版�?(<code>Version</code>)记录机制实现。即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一�?<code>“version”</code> 字段�?实现�?读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提 交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据 版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据�?</p><h4 id="cas思想" tabindex="-1"><code>CAS</code>思想 <a class="header-anchor" href="#cas思想" aria-label="Permalink to &quot;`CAS`思想&quot;">​</a></h4><p><code>CAS</code> 就是 <code>compare and swap</code>（比较交换），是一种很出名的无锁的算法，就是可以不使用锁机制实现线程间的同步。使用CAS线程是不会被阻塞的，所以又称为非阻塞同步。<code>CAS</code> 算法涉及到三个操作：需要读写内存�?<code>V</code>�?进行比较的�?<code>A</code>�?准备写入的�?<code>B</code>。当且仅�?<code>V</code> 的值等�?<code>A</code> 的值等�?<code>V</code> 的值的时候，才用 <code>B</code> 的值去更新 <code>V</code> 的值，否则不会执行任何操作（比较和替换是一个原子操�?<code>A</code> �?<code>V</code> 比较，<code>V</code> �?<code>B</code> 替换），一般情况下是一个自旋操作，即不断重试。缺点：高并发的情况下，很容易发生并发冲突，如果 <code>CAS</code> 一直失败，那么就会一直重试，浪费 <code>CPU</code> 资源�?</p><h4 id="原子�" tabindex="-1">原子�? <a class="header-anchor" href="#原子�" aria-label="Permalink to &quot;原子�?&quot;">​</a></h4><p>功能限制 <code>CAS</code> 是能保证单个变量的操作是原子性的，在 <code>Java</code> 中要配合使用 <code>volatile</code> 关键字来保证线程的安全；当涉及到多个变量的时�?<code>CAS</code> 无能为力；除此之�?<code>CAS</code> 实现需要硬件层面的支持，在 <code>Java</code> 的普通用户中无法直接使用，只能借助 <code>atomic</code> 包下的原子类实现，灵活性受到了限制�?</p><h3 id="_3-reentrantlock-使用方法-底层实现-�-synchronized-区别�" tabindex="-1">3.<code>ReenTrantLock</code> 使用方法？底层实现？�?<code>synchronized</code> 区别�? <a class="header-anchor" href="#_3-reentrantlock-使用方法-底层实现-�-synchronized-区别�" aria-label="Permalink to &quot;3.`ReenTrantLock` 使用方法？底层实现？�?`synchronized` 区别�?&quot;">​</a></h3><p>由于 <code>ReentrantLock</code> �?<code>java.util.concurrent</code> 包下提供的一套互斥锁，相�?<code>Synchronized</code>，<code>ReentrantLock</code>类提供了一些高级功能，主要有以下三项：</p><ul><li>等待可中断，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相当�?<code>Synchronized</code> 来说可以避免出现死锁的情况。通过 <code>lock.lockInterruptibly()</code>来实现这个机�?</li><li>公平锁，多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，<code>Synchronized</code> 锁非公平锁，<code>ReentrantLock</code> 默认的构造函数是创建的非公平锁，可以通过参数 <code>true</code> 设为公平锁，但公平锁表现的性能不是很好</li><li>锁绑定多个条件，一�?<code>ReentrantLock</code> 对象可以同时绑定对个对象。<code>ReenTrantLock</code> 提供了一�?<code>Condition</code>（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像 <code>synchronized</code> 要么随机唤醒一个线程要么唤醒全部线�?</li></ul><h4 id="使用方法" tabindex="-1">使用方法 <a class="header-anchor" href="#使用方法" aria-label="Permalink to &quot;使用方法&quot;">​</a></h4><p>基于 <code>API</code> 层面的互斥锁，需�?<code>lock()</code> �?<code>unlock()</code> 方法配合 <code>try/finally</code> 语句块来完成</p><h4 id="底层实现" tabindex="-1">底层实现 <a class="header-anchor" href="#底层实现" aria-label="Permalink to &quot;底层实现&quot;">​</a></h4><p><code> ReenTrantLock</code> 的实现是一种自旋锁，通过循环调用 <code>CAS</code> 操作来实现加锁。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。想尽办法避免线程进入内核的阻塞状态是我们去分析和理解锁设计的关键钥匙</p><h4 id="reentrantlock和synchronized-的区�" tabindex="-1"><code>ReenTrantLock</code>和<code>synchronized</code> 的区�? <a class="header-anchor" href="#reentrantlock和synchronized-的区�" aria-label="Permalink to &quot;`ReenTrantLock`和`synchronized` 的区�?&quot;">​</a></h4><p>1�?*底层实现**上来说，<code>synchronized</code> �?<code>JVM</code> 层面的锁，是 <code>Java</code> 关键字，通过 <code>monitor</code> 对象来完成（<code>monitorenter与monitorexit</code>），对象只有在同步块或同步方法中才能调用 <code>wait/notify</code> 方法；<code>ReentrantLock</code> 是从 <code>jdk1.5</code> 以来（<code>java.util.concurrent.locks.Lock</code>）提供的 <code>API</code> 层面的锁。<code>synchronized</code> 的实现涉及到锁的升级，具体为无锁、偏向锁、自旋锁、向OS申请重量级锁；<code>ReentrantLock</code> 实现则是通过利用 <code>CAS</code> （<code>CompareAndSwap</code>）自旋机制保证线程操作的原子性和 <code>volatile</code> 保证数据可见性以实现锁的功能</p><p>2�?*是否可手动释放：<code>**synchronized</code> 不需要用户去手动释放锁，<code>synchronized</code> 代码执行完后系统会自动让线程释放对锁的占用； <code>ReentrantLock</code> 则需要用户去手动释放锁，如果没有手动释放锁，就可能导致死锁现象。一般通过<code>lock()</code> �?<code>unlock()</code> 方法配合 <code>try/finally</code> 语句块来完成，使用释放更加灵�?</p><p>3�?<em>是否可中�?</em> <code>synchronized</code> 是不可中断类型的锁，除非加锁的代码中出现异常或正常执行完成； <code>ReentrantLock</code> 则可以中断，可通过 <code>trylock(long timeout,TimeUnit unit)</code> 设置超时方法或者将 <code>lockInterruptibly()</code> 放到代码块中，调�?<code>interrupt</code> 方法进行中断�?</p><p>4�?*是否公平�?**<code>synchronized</code> 为非公平�?<code>ReentrantLock</code> 则即可以选公平锁也可以选非公平锁，通过构造方法<code>new ReentrantLock</code> 时传�?<code>boolean</code> 值进行选择，为空默�?<code>false</code> 非公平锁，<code>true</code> 为公平锁</p><h3 id="_4-介绍一�-java-的内存模�" tabindex="-1">4.介绍一�?<code>Java</code> 的内存模�? <a class="header-anchor" href="#_4-介绍一�-java-的内存模�" aria-label="Permalink to &quot;4.介绍一�?`Java` 的内存模�?&quot;">​</a></h3><p><code>Java</code> 内存模型（<code>Java Memory Model，JMM</code>）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证�?<code>Java</code> 程序在各种平台下对内存的访问都能保证效果一致的机制及规范。<code>JMM</code> 是一种规范，是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。目的是保证并发编程场景中的原子性、可见性和有序性。所以，<code>Java</code> 内存模型，除了定义了一套规范，还提供了一系列原语，封装了底层实现后，供开发者直接使用。我们前面提到，并发编程要解�?*原子性、有序性和一致�?*的问题�?</p><ul><li><strong>原子性：</strong> �?<code>Java</code> 中，为了保证原子性，提供了两个高级的字节码指�?<code>Monitorenter</code> �?<code>Monitorexit</code>。这两个字节码，�?<code>Java</code> 中对应的关键字就�?<code>Synchronized</code>。因此，�?<code>Java</code> 中可以使�?<code>Synchronized</code> 来保证方法和代码块内的操作是原子性的</li><li><strong>可见性：</strong><code> Java</code> 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的。<code>Java</code> 中的 <code>Volatile</code> 关键字修饰的变量在被修改后可以立即同步到主内存。被其修饰的变量在每次使用之前都从主内存刷新。因此，可以使用 <code>Volatile</code> 来保证多线程操作时变量的可见性。除�?<code>Volatile</code>，<code>Java</code> 中的 <code>Synchronized</code> �?<code>Final</code> 两个关键字也可以实现可见性。只不过实现方式不同</li><li><strong>有序性：</strong>�?<code>Java</code> 中，可以使用 <code>Synchronized</code> �?<code>Volatile</code> 来保证多线程之间操作的有序性。区别：<code>Volatile</code> 禁止指令重排。<code>Synchronized</code> 保证同一时刻只允许一条线程操�?</li></ul><h3 id="_5-volatile-作用-底层实现-单例模式�-volatile-的作用" tabindex="-1">5.<code>volatile</code> 作用？底层实现？单例模式�?<code>volatile</code> 的作用？ <a class="header-anchor" href="#_5-volatile-作用-底层实现-单例模式�-volatile-的作用" aria-label="Permalink to &quot;5.`volatile` 作用？底层实现？单例模式�?`volatile` 的作用？&quot;">​</a></h3><h4 id="作用" tabindex="-1">作用 <a class="header-anchor" href="#作用" aria-label="Permalink to &quot;作用&quot;">​</a></h4><p>保证数据的“可见性”：�?<code>volatile</code> 修饰的变量能够保证每个线程能够获取该变量的最新值，从而避免出现数据脏读的现象�?禁止指令重排：在多线程操作情况下，指令重排会导致计算结果不一致�?</p><h4 id="底层实现-1" tabindex="-1">底层实现 <a class="header-anchor" href="#底层实现-1" aria-label="Permalink to &quot;底层实现&quot;">​</a></h4><p>观察加入 <code>volatile</code> 关键字和没有加入 <code>volatile</code> 关键字时所生成的汇编代码发现，加入 <code>volatile</code> 关键字时，会多出一�?<code>lock</code> 前缀指令�?<code>lock</code> 前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提�?个功能：</p><ul><li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完�?</li><li>它会强制将对缓存的修改操作立即写入主�?</li><li>如果是写操作，它会导致其�?<code>CPU</code> 中对应的缓存行无�?</li></ul><h4 id="单例模式�-volatile-的作�" tabindex="-1">单例模式�?<code>volatile</code> 的作�? <a class="header-anchor" href="#单例模式�-volatile-的作�" aria-label="Permalink to &quot;单例模式�?`volatile` 的作�?&quot;">​</a></h4><p>防止代码读取�?<code>instance</code> 不为 <code>null</code> 时，<code>instance</code> 引用的对象有可能还没有完成初始化</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Singleton</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> volatile</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Singleton instance </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//禁止指令重排</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Singleton</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {        </span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Singleton </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(instance</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            synchronized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Singleton.class) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(instance</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    instance </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Singleton</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> instance;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="_6-threadlocal-原理" tabindex="-1">6.<code>ThreadLocal</code> 原理 <a class="header-anchor" href="#_6-threadlocal-原理" aria-label="Permalink to &quot;6.`ThreadLocal` 原理&quot;">​</a></h3><h3 id="_7-cas-�-aba-问题" tabindex="-1">7.<code>CAS</code> �?<code>ABA</code> 问题 <a class="header-anchor" href="#_7-cas-�-aba-问题" aria-label="Permalink to &quot;7.`CAS` �?`ABA` 问题&quot;">​</a></h3><h3 id="_8-原子类的实现原理" tabindex="-1">8.原子类的实现原理 <a class="header-anchor" href="#_8-原子类的实现原理" aria-label="Permalink to &quot;8.原子类的实现原理&quot;">​</a></h3><h3 id="_9-说一�-currenthashmap-如何实现线程安全�" tabindex="-1">9.说一�?<code>CurrentHashMap</code> 如何实现线程安全�? <a class="header-anchor" href="#_9-说一�-currenthashmap-如何实现线程安全�" aria-label="Permalink to &quot;9.说一�?`CurrentHashMap` 如何实现线程安全�?&quot;">​</a></h3><h1 id="jvm" tabindex="-1">JVM <a class="header-anchor" href="#jvm" aria-label="Permalink to &quot;JVM&quot;">​</a></h1><h2 id="知识体系-2" tabindex="-1">知识体系 <a class="header-anchor" href="#知识体系-2" aria-label="Permalink to &quot;知识体系&quot;">​</a></h2><h2 id="questions-2" tabindex="-1">Questions <a class="header-anchor" href="#questions-2" aria-label="Permalink to &quot;Questions&quot;">​</a></h2><h3 id="_1-jvm-内存划分" tabindex="-1">1.<code>JVM</code> 内存划分 <a class="header-anchor" href="#_1-jvm-内存划分" aria-label="Permalink to &quot;1.`JVM` 内存划分&quot;">​</a></h3><h3 id="_2-gc-垃圾收集�" tabindex="-1">2.<code>GC</code> 垃圾收集�? <a class="header-anchor" href="#_2-gc-垃圾收集�" aria-label="Permalink to &quot;2.`GC` 垃圾收集�?&quot;">​</a></h3><h3 id="_3-垃圾收集算法-为什么新生代用标�-复制老年代用标记-整理" tabindex="-1">3.垃圾收集算法，为什么新生代用标�?复制老年代用标记-整理 <a class="header-anchor" href="#_3-垃圾收集算法-为什么新生代用标�-复制老年代用标记-整理" aria-label="Permalink to &quot;3.垃圾收集算法，为什么新生代用标�?复制老年代用标记-整理&quot;">​</a></h3><h3 id="_4-类加载流�" tabindex="-1">4.类加载流�? <a class="header-anchor" href="#_4-类加载流�" aria-label="Permalink to &quot;4.类加载流�?&quot;">​</a></h3><h3 id="_5-双亲委派机制-怎么样会打破双亲委派模型" tabindex="-1">5.双亲委派机制，怎么样会打破双亲委派模型 <a class="header-anchor" href="#_5-双亲委派机制-怎么样会打破双亲委派模型" aria-label="Permalink to &quot;5.双亲委派机制，怎么样会打破双亲委派模型&quot;">​</a></h3><h3 id="_6-jvm-1-7-�-1-8-的区�" tabindex="-1">6.<code>JVM</code> 1.7 �?1.8 的区�? <a class="header-anchor" href="#_6-jvm-1-7-�-1-8-的区�" aria-label="Permalink to &quot;6.`JVM` 1.7 �?1.8 的区�?&quot;">​</a></h3><h1 id="数据�" tabindex="-1">数据�? <a class="header-anchor" href="#数据�" aria-label="Permalink to &quot;数据�?&quot;">​</a></h1><h2 id="知识体系-3" tabindex="-1">知识体系 <a class="header-anchor" href="#知识体系-3" aria-label="Permalink to &quot;知识体系&quot;">​</a></h2><h2 id="questions-3" tabindex="-1">Questions <a class="header-anchor" href="#questions-3" aria-label="Permalink to &quot;Questions&quot;">​</a></h2><h3 id="_1-mysql的引擎了解吗-默认的是哪个-innodb-�-myisam-的区别" tabindex="-1">1.<code>MySQL</code>的引擎了解吗？默认的是哪个？<code>InnoDB </code>�?<code>myISAM</code> 的区别？ <a class="header-anchor" href="#_1-mysql的引擎了解吗-默认的是哪个-innodb-�-myisam-的区别" aria-label="Permalink to &quot;1.`MySQL`的引擎了解吗？默认的是哪个？`InnoDB `�?`myISAM` 的区别？&quot;">​</a></h3><p><code>myISAM</code>: 支持表锁，适合读密集的场景，不支持外键，不支持事务，索引与数据在不同的文件，非聚簇索引</p><p><code>InnoDB</code>:支持行、表锁，默认为行锁，适合并发场景，支持外键，支持事务，索引与数据同一文件，聚簇索�?</p><h3 id="_2-介绍-mvcc" tabindex="-1">2.介绍 <code>MVCC</code> <a class="header-anchor" href="#_2-介绍-mvcc" aria-label="Permalink to &quot;2.介绍 `MVCC`&quot;">​</a></h3><p><code>MVCC</code> 是一种多版本并发控制机制，在大多数情况下代替行级锁，使用 <code>MVCC</code>，能降低其系统开销。<code>MVCC</code> 是通过保存数据在某个时间点的快照来实现�?。不同存储引擎的 <code>MVCC</code> 实现是不同的，典型的有乐观并发控制和悲观并发控制。<code>InnoDB</code> �?<code>MVCC</code> 是通过在每行记录后面保存两个隐藏的列来实现的，这两个列，分别保存了这个行的创建时间，一个保存的是行的删除时间。这里存储的并不是实际的时间值，而是系统版本�?可以理解为事务的 <code>ID</code>)，每开始一个新的事务，系统版本号就会自动递增，事务开始时刻的系统版本号会作为事务�?<code>ID</code>。<code>InnoDB</code> 只会查找版本早于当前事务版本的数据行(也就是行的系统版本号小于或等于事务的系统版本�?，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的�?</p><h3 id="_3-mysql-中一�-sql-语句的执行过�" tabindex="-1">3.<code>MySQL</code> 中一�?<code>SQL</code> 语句的执行过�? <a class="header-anchor" href="#_3-mysql-中一�-sql-语句的执行过�" aria-label="Permalink to &quot;3.`MySQL` 中一�?`SQL` 语句的执行过�?&quot;">​</a></h3><p>以查询语句为�?</p><div class="language-mysql vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tb_student  A </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">age</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;18&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> and</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;张三&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ul><li>先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，�?<code>MySQL8.0</code> 版本以前，会先查询缓存，以这�?<code>sql</code> 语句�?<code>key</code> 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一�?</li><li>通过分析器进行词法分析，提取 <code>sql</code> 语句的关键元素，比如提取上面这个语句是查�?<code>select</code>，提取需要查询的表名�?<code>tb_student</code>,需要查询所有的列，查询条件是这个表�?<code>id=&#39;1&#39;</code>。然后判断这�?<code>sql</code> 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一�?</li><li>接下来就是优化器进行确定执行方案，上面的 <code>sql</code> 语句，可以有两种执行方案�?a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是18�?b.先找出学生中年龄18岁的学生，然后再查询姓名为“张三”的学生�?那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了</li><li>进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果</li></ul><h3 id="_4-如何查看-sql-语句的执行计划-用哪个关键字-使用这个关键字可以得到哪些信息�" tabindex="-1">4.如何查看 <code>sql</code> 语句的执行计划？用哪个关键字？使用这个关键字可以得到哪些信息�? <a class="header-anchor" href="#_4-如何查看-sql-语句的执行计划-用哪个关键字-使用这个关键字可以得到哪些信息�" aria-label="Permalink to &quot;4.如何查看 `sql` 语句的执行计划？用哪个关键字？使用这个关键字可以得到哪些信息�?&quot;">​</a></h3><p>用关键字 <code>explain</code> 来查看执行计�?</p><p><img src="https://i.loli.net/2021/07/01/xPIajcdQrysEJON.png" alt=""></p><p><img src="https://i.loli.net/2021/07/01/k8TmrSEaK4M1lpc.png" alt=""></p><h3 id="_5-聚簇索引和非聚簇索引的区别-非聚簇索引是如何查询的" tabindex="-1">5.聚簇索引和非聚簇索引的区别，非聚簇索引是如何查询的？ <a class="header-anchor" href="#_5-聚簇索引和非聚簇索引的区别-非聚簇索引是如何查询的" aria-label="Permalink to &quot;5.聚簇索引和非聚簇索引的区别，非聚簇索引是如何查询的？&quot;">​</a></h3><p>聚簇索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚集索引的叶子节点称为数据页。这个特性决定了索引组织表中数据也是索引的一部分，每张表只能拥有一个聚簇索引。<code>InnoDB</code> 通过主键聚集数据，如果没有定义主键，<code>InnoDB</code> 会选择非空的唯一索引代替。如果没有这样的索引，<code>InnoDB</code> 会隐式的定义一个主键来作为聚簇索引�?</p><p>在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找。辅助索引叶子节点存储的不再是行的物理位置，而是主键值。通过辅助索引首先找到的是主键值，再通过主键值找到数据行的数据页，再通过数据页中�?<code>Page Directory</code>找到数据行。<code>InnoDB</code> 辅助索引的叶子节点并不包含行记录的全部数据，叶子节点除了包含键值外，还包含了相应行数据的聚簇索引键。辅助索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个辅助索引。在 <code>InnoDB</code> 中有时也称辅助索引为二级索引�?</p><p>二级索引需要两次索引查找， 二级索引中保存的“行指针”的本质：不是物理地址的指针，而是行的主键值。所以通过二级索引查找行，引擎需要找到二级索引的子节点获得对应主键值，然后根据该值去聚簇索引找到对应行�?出现重复工作：两次B-Tree查找，而非一次。对于InnoDB，自适应哈希索引能够减少这样重复�?</p><h3 id="_6-mysql�-acid-分别解释一�" tabindex="-1">6.<code>MySQL</code>�?<code>ACID</code>，分别解释一�? <a class="header-anchor" href="#_6-mysql�-acid-分别解释一�" aria-label="Permalink to &quot;6.`MySQL`�?`ACID`，分别解释一�?&quot;">​</a></h3><p><strong>原⼦性：</strong> 事务是最⼩的执⾏单位，不允许分割。事务的原⼦性确保动作要么全部完成，要么全不执行</p><p><strong>一致性：</strong> 执⾏事务前后，数据保持⼀致，多个事务对同⼀个数据读取的结果是相同的</p><p><strong>隔离性：</strong> 并发访问数据库时，⼀个⽤户的事务不被其他事务所⼲扰，各并发事务之间数据库是独⽴�?</p><p><strong>持久性：</strong> ⼀个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发⽣故障也不应该对其有任何影�?</p><h3 id="_7-数据库索引的实现原理" tabindex="-1">7.数据库索引的实现原理 <a class="header-anchor" href="#_7-数据库索引的实现原理" aria-label="Permalink to &quot;7.数据库索引的实现原理&quot;">​</a></h3><p><code>MySQL</code> 中默认的引擎�?<code>InnoDB</code>，<code>innoDB</code> 的索引使用的�?<code>B+</code> 树实�?</p><p>*<em><code>B+</code> 树对�?<code>B树</code> 的好�?</em></p><ul><li><p><code>IO</code> 次数少：<code>B+</code> 树的中间结点只存放索引，数据都存在叶结点中，因此中间结点可以存更多的数据，让索引树更加矮�?</p></li><li><p>范围查询效率更高：<code>B</code> 树需要中序遍历整个树，<code>B+</code> 树只需要遍历叶结点中的链表</p></li><li><p>查询效率更加稳定：每次查询都需要从根结点到叶结点，路径长度相同，所以每次查询的效率都差不多</p></li></ul><p>*<em>使用 <code>B</code> 树索引和哈希索引的比�?</em></p><p>哈希索引能以 <code>O(1)</code> 时间进行查找，但是只支持精确查找，无法用于部分查找和范围查找，无法用于排序与分组；<code>B</code> 树索引支持大于小于等于查找，范围查找。哈希索引遇到大量哈希值相等的情况后查找效率会降低。哈希索引不支持数据的排�?</p><h3 id="_8-联合索引-最左前缀匹配规则" tabindex="-1">8.联合索引，最左前缀匹配规则 <a class="header-anchor" href="#_8-联合索引-最左前缀匹配规则" aria-label="Permalink to &quot;8.联合索引，最左前缀匹配规则&quot;">​</a></h3><p>联合索引又叫复合索引。两个或更多个列上的索引被称作复合索引。对于复合索引：<code>MySQL</code> 从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。当最左侧字段是常量引用时，索引就十分有效</p><p>*<em>优点�?</em></p><ul><li><p>避免回表</p></li><li><p>两个单列查询返回行较多，同时查返回行较少，联合索引更高效</p></li></ul><p>*<em>如何设计�?</em></p><ul><li><p>等值查询中，查询条件a返回的条目比较多，查询条件b返回的条目比较多，而同时查询a、b返回的条目比较少，那么适合建立联合索引</p></li><li><p>对于有等值查询的列和范围查询的列，等值查询的列建在前、范围查询的列建在后比较实用</p></li><li><p>如果联合索引列的前置列与索引单列一致，那么单列查询可以用到索引，这样就避免了再建单列索引，因此联合索引的前置列应尽量与单列一�?</p></li></ul><p>**最左前缀匹配原则�?*在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹�?</p><h3 id="_9-索引怎么优化" tabindex="-1">9.索引怎么优化 <a class="header-anchor" href="#_9-索引怎么优化" aria-label="Permalink to &quot;9.索引怎么优化&quot;">​</a></h3><ul><li><code>like</code> 语句的前导模糊查询不能使用索�?</li><li><strong>联合索引最左前缀原则</strong></li><li>不能使用索引中范围条件右边的�?范围列可以用到索�?，范围列之后列的索引全失�?</li><li>不要在索引列上面做任何操�?计算、函�?，否则会导致索引失效而转向全表扫�?</li><li>使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空�?</li><li>常查询数据建立索引或者组合索引，不要建立无意义的索引</li></ul><h3 id="_10-事物隔离级别" tabindex="-1">10.事物隔离级别 <a class="header-anchor" href="#_10-事物隔离级别" aria-label="Permalink to &quot;10.事物隔离级别&quot;">​</a></h3><ul><li>读未提交（read uncommitted，RU�?一个事务还没提交，它的变更就能被其它事务看�?</li><li>读已提交（read committed，RC�?一个事务提交后，其变更才会被其他事务看�?</li><li>可重复读（repeatable read，RR�?一个事务执行过程中看到的数据，和该事务在启动时看到的数据一致�?自然未提交的变更对其他事务也是不可见的。一个事务启动时，能够看到所有已提交的事务结果。但之后的该事务执行期间，其他事务的更新对它就不可见�?</li><li>串行化（serializable�?对同行记录，“写”加“写锁”，“读”加“读锁”。出现读写锁冲突时，后访问的事务必须等前一个事务执行完�?</li></ul><h3 id="_11-binlog、redo-log、undo-log" tabindex="-1">11.<code>binlog</code>、<code>redo log</code>、<code>undo log</code> <a class="header-anchor" href="#_11-binlog、redo-log、undo-log" aria-label="Permalink to &quot;11.`binlog`、`redo log`、`undo log`&quot;">​</a></h3><h4 id="binlog" tabindex="-1"><code>binlog</code> <a class="header-anchor" href="#binlog" aria-label="Permalink to &quot;`binlog`&quot;">​</a></h4><p><code>binlog</code>用于记录数据库执行的写入性操�?不包括查�?信息，以二进制的形式保存在磁盘中。<code>binlog</code>是<code>mysql</code>的逻辑日志，并且由<code>Server</code>层进行记录，使用任何存储引擎的<code>mysql</code>数据库都会记录<code>binlog</code>日志</p><p>*<em>使用场景�?</em></p><ol><li><strong>主从复制</strong>：在<code>Master</code>端开启<code>binlog</code>，然后将<code>binlog</code>发送到各个<code>Slave</code>端，<code>Slave</code>端重放<code>binlog</code>从而达到主从数据一�?</li><li><strong>数据恢复</strong>：通过使用<code>mysqlbinlog</code>工具来恢复数�?</li></ol><h4 id="redo-log" tabindex="-1"><code>redo log</code> <a class="header-anchor" href="#redo-log" aria-label="Permalink to &quot;`redo log`&quot;">​</a></h4><p><code>redo log</code>包括两部分：一个是内存中的日志缓冲(<code>redo log buffer</code>)，另一个是磁盘上的日志文件(<code>redo log file</code>)。<code>mysql</code>每执行一条<code>DML</code>语句，先将记录写入<code>redo log buffer</code>，后续某个时间点再一次性将多个操作记录写到<code>redo log file</code>。这�?*先写日志，再写磁�?*的技术就是<code>MySQL</code>里经常说到的<code>WAL(Write-Ahead Logging)</code> 技�?</p><p><strong>区别</strong></p><table tabindex="0"><thead><tr><th></th><th>redo log</th><th>binlog</th></tr></thead><tbody><tr><td>文件大小</td><td><code>redo log</code>的大小是固定的�?</td><td><code>binlog</code>可通过配置参数<code>max_binlog_size</code>设置每个<code>binlog</code>文件的大小�?</td></tr><tr><td>实现方式</td><td><code>redo log</code>是<code>InnoDB</code>引擎层实现的，并不是所有引擎都有�?</td><td><code>binlog</code>是<code>Server</code>层实现的，所有引擎都可以使用 <code>binlog</code>日志</td></tr><tr><td>记录方式</td><td>redo log 采用循环写的方式记录，当写到结尾时，会回到开头循环写日志�?</td><td>binlog 通过追加的方式记录，当文件大小大于给定值后，后续的日志会记录到新的文件�?</td></tr><tr><td>适用场景</td><td><code>redo log</code>适用于崩溃恢�?crash-safe)</td><td><code>binlog</code>适用于主从复制和数据恢复</td></tr></tbody></table><h4 id="undo-log" tabindex="-1"><code>undo log</code> <a class="header-anchor" href="#undo-log" aria-label="Permalink to &quot;`undo log`&quot;">​</a></h4><p><code>undo log</code> 主要有两个作用：<code>回滚</code>和<code>多版本控�?MVCC)</code> 。在数据修改的时候，不仅记录�?<code>redo log</code>，还记录 <code>undo log</code>，如果因为某些原因导致事务失败或回滚了，可以�?<code>undo log</code> 进行回滚（保证了原子性） 。<code>undo log</code> 主要存储的是<code>逻辑日志</code>，用来回滚的<code>相反操作日志</code>。比如我们要 <code>insert</code> 一条数据了，那 <code>undo log</code> 会记录的一条对应的 <code>delete</code> 日志。我们要 <code>update</code> 一条记录时，它会记录一条对应相反的 <code>update</code> 记录。因�?<code>undo log</code> 存储着修改之前的数据，相当于一个前版本，``MVCC` 实现的是读写不阻塞，读的时候只要返回前一个版本的数据就行�?</p><h1 id="spring" tabindex="-1">Spring <a class="header-anchor" href="#spring" aria-label="Permalink to &quot;Spring&quot;">​</a></h1><h2 id="知识体系-4" tabindex="-1">知识体系 <a class="header-anchor" href="#知识体系-4" aria-label="Permalink to &quot;知识体系&quot;">​</a></h2><h2 id="questions-4" tabindex="-1">Questions <a class="header-anchor" href="#questions-4" aria-label="Permalink to &quot;Questions&quot;">​</a></h2><h3 id="_1-sping-ioc-aop-的实现原�" tabindex="-1">1.<code>Sping IOC AOP</code> 的实现原�? <a class="header-anchor" href="#_1-sping-ioc-aop-的实现原�" aria-label="Permalink to &quot;1.`Sping IOC AOP` 的实现原�?&quot;">​</a></h3><h3 id="_2-spring-事务的实现原�" tabindex="-1">2.<code>Spring</code> 事务的实现原�? <a class="header-anchor" href="#_2-spring-事务的实现原�" aria-label="Permalink to &quot;2.`Spring` 事务的实现原�?&quot;">​</a></h3><h3 id="_3-bean-的生命周�" tabindex="-1">3.<code>bean</code> 的生命周�? <a class="header-anchor" href="#_3-bean-的生命周�" aria-label="Permalink to &quot;3.`bean` 的生命周�?&quot;">​</a></h3><h1 id="redis" tabindex="-1">Redis <a class="header-anchor" href="#redis" aria-label="Permalink to &quot;Redis&quot;">​</a></h1><h2 id="知识体系-5" tabindex="-1">知识体系 <a class="header-anchor" href="#知识体系-5" aria-label="Permalink to &quot;知识体系&quot;">​</a></h2><h2 id="questions-5" tabindex="-1">Questions <a class="header-anchor" href="#questions-5" aria-label="Permalink to &quot;Questions&quot;">​</a></h2><h3 id="_1-基于-redis-的分布式锁是如何实现�" tabindex="-1">1.基于 <code>redis</code> 的分布式锁是如何实现�? <a class="header-anchor" href="#_1-基于-redis-的分布式锁是如何实现�" aria-label="Permalink to &quot;1.基于 `redis` 的分布式锁是如何实现�?&quot;">​</a></h3><p><img src="https://i.loli.net/2021/07/01/WwxOC1ULHkAdIfF.png" alt=""></p><p><strong>实现思想</strong>：获取锁的时候，使用 <code>setnc</code> 加锁，并使用 <code>expire</code> 命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的 <code>value</code> 值为一个随机生成的 <code>UUID</code>，通过此在释放锁的时候进行判断；获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁；释放锁的时候，通过 <code>UUID</code> 判断是不是该锁，若是该锁，则执行 <code>delete</code> 进行锁释放。因�?<code>redis</code> 是单线程的，这样的话，如�?个请求打过来的话，只有一个请求能获得锁，获得锁即�?<code>key</code> 设置一个值，如果这个 <code>key</code> 存在就设置失败，也就是只有一个请求可以设置成功，这个请求处理完之后，会把这个 <code>key</code> 释放掉，那么剩下等着�?个请求一定会有一个请求重新对这个 <code>key</code> 设置一个值再次获得锁，依次类推。这样即当不同机子上的请求打过来的时候能够保证某一时刻只能有一个请求去消费资源，间接地形成一种加锁的机制�?</p><h4 id="redisson-实现-redis-分布式锁" tabindex="-1"><code>Redisson</code> 实现 <code>Redis</code> 分布式锁 <a class="header-anchor" href="#redisson-实现-redis-分布式锁" aria-label="Permalink to &quot;`Redisson` 实现 `Redis` 分布式锁&quot;">​</a></h4><ul><li><p>加锁机制：客户端1面对分布式集群下，首先根�?<code>hash</code> 节点选择一台机器，发送一�?<code>lua</code> 脚本（保证复杂业务的原子性），将 <code>key </code>加锁（如�?<code>key </code>不存在就进行加锁）、设置过期时间、客户端 <code>id</code></p></li><li><p>锁互斥机制：如果客户�?执行同样的lua脚本，代码中则会判断该锁 <code>key</code> 已存在，紧接着判断�?<code>key</code> �?<code>hash</code> 数据结构中是否包含客户端2�?<code>id</code>，如果不包含则会获得一个返回的数字，代表这个锁 <code>key</code> 的剩余生存时间，紧接着客户�?会进�?<code>while</code> 循环不断尝试加锁</p></li><li><p><code>watch dog</code> 自动延期机制：客户端1加锁有默认生存时间，如果想继续持有，可以在加锁成功时启动一�?<code>watch dog</code>看门狗（后台线程），�?0秒检查一下，如果客户�?还持有锁 <code>key</code>，就会不断的延长�?<code>key</code> 的生存时间�?*(是对1中如何设置有效期的优�?**</p></li><li><p>可重入加锁机制： <code>hash</code> 数据结构中的客户�?<code>id</code> 加锁次数+1**(是对锁只能加一次，不可重入的优�?**</p></li><li><p>释放锁机制：每次对数据结构中的加锁次�?1，当加锁次数�?，说明该客户端不持有锁，此时会从 <code>redis</code> 里删除这�?<code>key</code> ，另外的客户端可以尝试完成加锁�?</p></li></ul><p><strong>缺点</strong>：如果采用这种方案，对某�?<code>redis master</code> 实例，写�?<code>mylock</code> 这种锁的 <code>value</code>，此时异步复制给对应�?<code>master slave</code> 实例，这个过程中一�?<code>redis master</code> 宕机，<code>redis slave</code> 就变成了 <code>redis master</code> 会导致客户端2尝试加锁时，在新的<code>redis master </code>上完成了加锁，而客户端1也以为自己成功加了锁。导致多个客户端对一个分布式锁完成了加锁，导致各种脏数据产生。【<code>redis</code> 主从架构的主从异步复制导�?<code>redis</code> 分布式锁的最大缺陷�?</p><h3 id="_2-跳表数据结构-redis-中哪里用到了跳表" tabindex="-1">2.跳表数据结构，<code>redis</code> 中哪里用到了跳表 <a class="header-anchor" href="#_2-跳表数据结构-redis-中哪里用到了跳表" aria-label="Permalink to &quot;2.跳表数据结构，`redis` 中哪里用到了跳表&quot;">​</a></h3><p>跳跃表（<a href="http://en.wikipedia.org/wiki/Skip_list" target="_blank" rel="noreferrer">skiplist</a>）是一种随机化的数据， �?William Pugh 在论文<a href="http://www.cl.cam.ac.uk/teaching/0506/Algorithms/skiplists.pdf" target="_blank" rel="noreferrer">《Skip lists: a probabilistic alternative to balanced trees》</a>中提出， 跳跃表以有序的方式在层次化的链表中保存元素， 效率和平衡树媲美 —�?查找、删除、添加等操作都可以在对数期望时间下完成， 并且比起平衡树来说， 跳跃表的实现要简单直观得�?</p><p><img src="https://i.loli.net/2021/08/21/ilBuYTAOrxfEdSm.jpg" alt="ilBuYTAOrxfEdSm"></p><p>跳跃表主要由以下部分构成�?</p><ul><li>表头（head）：负责维护跳跃表的节点指针</li><li>跳跃表节点：保存着元素值，以及多个�?</li><li>层：保存着指向其他元素的指针。高层的指针越过的元素数量大于等于低层的指针，为了提高查找的效率，程序总是从高层先开始访问，然后随着元素值范围的缩小，慢慢降低层�?</li><li>表尾：全部由 <code>NULL</code> 组成，表示跳跃表的末�?</li></ul><p><code>redis</code> 数据类型 <code>zset</code> 实现有序集合，底层使用的数据结构是跳�?</p><h3 id="_3-出现缓存雪崩、击穿、穿透的情况及解决方�" tabindex="-1">3.出现缓存雪崩、击穿、穿透的情况及解决方�? <a class="header-anchor" href="#_3-出现缓存雪崩、击穿、穿透的情况及解决方�" aria-label="Permalink to &quot;3.出现缓存雪崩、击穿、穿透的情况及解决方�?&quot;">​</a></h3><h4 id="缓存雪崩" tabindex="-1">缓存雪崩 <a class="header-anchor" href="#缓存雪崩" aria-label="Permalink to &quot;缓存雪崩&quot;">​</a></h4><p><strong>缓存雪崩</strong>指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉�?</p><p>*<em>解决方案�?</em></p><ul><li>**Redis 高可�?*，主�?哨兵，<code>Redis cluster</code>，避免全盘崩�?</li><li>本地 ehcache 缓存 + hystrix <strong>限流&amp;降级</strong>，避�?<code>MySQL</code> 被打�?</li><li>缓存数据�?<em>过期时间设置随机</em>*，防止同一时间大量数据过期现象发生</li><li><strong>逻辑上永不过�?*给每一个缓存数据增加相应的</strong>缓存标记**，缓存标记失效则更新数据缓存</li><li><strong>多级缓存</strong>，失效时通过二级更新一级，由第三方插件更新二级缓存</li></ul><h4 id="缓存穿�" tabindex="-1">*<em>缓存穿�?</em> <a class="header-anchor" href="#缓存穿�" aria-label="Permalink to &quot;**缓存穿�?*&quot;">​</a></h4><p>**缓存穿�?*是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉�?</p><p>*<em>解决方案�?</em></p><ul><li>**接口层增加校�?*，如用户鉴权校验，id 做基础校验，id&lt;=0 的直接拦�?</li><li>从缓存取不到的数据，在数据库中也没有取到，这时也可以�?<em>key-value 对写�?key-null</em>*，缓存有效时间可以设置短点，�?0秒。这样可以防止攻击用户反复用同一个id暴力攻击</li><li>采用**布隆过滤�?*，将所有可能存在的数据哈希到一个足够大�?<code>bitmap</code> 中，一个一定不存在的数据会被这�?<code>bitmap</code> 拦截掉，从而避免了对底层存储系统的查询压力</li></ul><h4 id="缓存击穿" tabindex="-1"><strong>缓存击穿</strong> <a class="header-anchor" href="#缓存击穿" aria-label="Permalink to &quot;**缓存击穿**&quot;">​</a></h4><p>由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据�?</p><p>*<em>解决方案�?</em></p><ul><li>设置**热点数据永远不过�?*，异步线程处�?</li><li>�?<em>写回操作加互斥锁</em>*，查询失败默认值快速返�?</li><li>缓存预热</li></ul><p>�? 系统上线后，将相�?*可预期（例如排行榜）**热点数据直接加载到缓�?</p><p>�? 写一个缓存刷新页面，手动操作热点数据**（例如广告推广）**上下�?</p><h3 id="_4-持久化策�" tabindex="-1">4.持久化策�? <a class="header-anchor" href="#_4-持久化策�" aria-label="Permalink to &quot;4.持久化策�?&quot;">​</a></h3><h4 id="rdb" tabindex="-1"><code>RDB</code> <a class="header-anchor" href="#rdb" aria-label="Permalink to &quot;`RDB`&quot;">​</a></h4><p><code>RDB</code> 持久化是指在指定时间间隔内将内存中的数据集快照写入磁盘。实际上 <code>fork</code> 子线程，先将数据集写入临时文件，写入成功后，在替换之前的文件，用二进制压缩文件，<code>RDB</code> �?<code>Redis</code> 默认的持久化方式，会在对应目录下生产一个<code>dump.rdb</code> 文件，重启会通过加载 <code>dump.rdb</code> 文件恢复数据</p><p><strong>优点</strong></p><ul><li><code>RDB</code> 会生成多个数据文件，每个文件都代表了某时�?<code>redis</code> 中的所有数据，这种方式非常适合�?<em>冷备</em>*，可将这种完整数据文件发送到云服务器存储，比�?<code>ODPS</code> 分布式存储，以预定好的备份策略来定期备份 <code>redis</code> 中的数据</li><li><code>RDB</code> �?<code>Redis</code> 对外提供的读写服务，影响非常小，可让 <code>redis</code> 保持高性能，因�?<code>redis</code> 主进程只�?<code>fork</code> 一个子进程，让子进程执�?<code>RDB</code></li><li>相对�?<code>AOF</code>，直接基�?<code>RDB</code> 文件重启和恢�?<code>redis</code>进程，更加快�?</li></ul><p><strong>缺点</strong></p><ul><li><code>fork</code> 耗内存，<code>copy-on-write</code> 策略 <code>RDB </code>每次�?<code>fork</code> 子进程来执行 <code>RDB</code> 快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数�?</li><li>不可控，容易丢失数据 一�?<code>RDB</code> 每隔5分钟，或者更长时间生成一次，若过程中 <code>redis</code> 宕机，就会丢失最近未持久化的数据</li></ul><h4 id="aof" tabindex="-1"><code>AOF</code> <a class="header-anchor" href="#aof" aria-label="Permalink to &quot;`AOF`&quot;">​</a></h4><p><code>AOF</code>持久化是以日志的形式记录记录每一个增删操作然后追加到文件中。<code>AOF</code>的出现是为了弥补<code>RDB</code>备份的不足（数据不一致性）</p><p>*<em>AOF的备份策�?</em></p><ul><li><code>appendfsync always</code>：每次有数据修改发生时都会同�?</li><li><code>appendfsync everysec</code>：每秒同步一�?</li><li><code>appendsync no</code>：让操作系统决定何时进行同步</li></ul><p><strong>优点</strong></p><ul><li>更好避免数据丢失 一般<code>AOF</code>每隔1s，通过子进程执行一次<code>fsync</code>，最多丢1s数据</li><li><code>append-only</code>模式追加�?所以没有任何磁盘寻址的开销，写入性能高，且文件不易破损，即使文件尾部破损，也易修�?</li><li>日志文件即使过大，出现后台重写操作，也不会影响客户端的读�?因为在<code>rewrite log</code>时，会压缩其中的指令，创建出一份需要恢复数据的最小日志。在创建新日志时，旧日志文件还是照常写入。当新的<code>merge</code>后的日志文件准备好时，再交换新旧日志文件即可</li></ul><p><strong>缺点</strong></p><ul><li>对于同一份数据，<code>AOF</code>日志一般比<code>RDB</code>快照更大，恢复慢</li><li><code>AOF</code>开启后，写<code>QPS</code>会比<code>RDB</code>的低，因为<code>AOF</code>一般会配置成每s <code>fsync</code>一次日志文件，当然，每s一次<code>fsync</code>，性能也还是很高的</li></ul><h3 id="_5-主从复制原理" tabindex="-1">5.主从复制原理 <a class="header-anchor" href="#_5-主从复制原理" aria-label="Permalink to &quot;5.主从复制原理&quot;">​</a></h3><p>主从复制，是指将一台<code>redis</code>服务器的数据，复制到其他的<code>redis</code>服务器。前者称为主节点(<code>master</code>)，后者称为从节点(<code>slave</code>)。数据的复制是单向的，只能由主节点到从节�?</p><p><strong>作用</strong></p><ul><li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方�?</li><li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余</li><li>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写<code>redis</code>数据时应用连接主节点，读<code>redis</code>数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高<code>redis</code>服务器的并发�?</li><li>高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是<code>redis</code>高可用的基础</li></ul><p><strong>原理</strong></p><ul><li><p>通过从服务器发送到<code>PSYNC</code>命令给主服务�?</p></li><li><p>如果是首次连接，触发一�?<em>全量复制</em>*。此时主节点会启动一个后台线程，生成 <code>RDB</code> 快照文件</p></li><li><p>主节点会将这�?<code>RDB</code> 发送给从节点，<code>slave</code> 会先写入本地磁盘，再从本地磁盘加载到内存�?</p></li><li><p><code>master</code>会将此过程中的写命令写入缓存，从节点<strong>实时同步</strong>这些数据</p></li><li><p>如果网络断开了连接，自动重连后主节点通过命令传播<strong>增量复制</strong>给从节点部分缺少的数�?</p></li></ul><h3 id="_6-数据库缓存一致�" tabindex="-1">6.数据库缓存一致�? <a class="header-anchor" href="#_6-数据库缓存一致�" aria-label="Permalink to &quot;6.数据库缓存一致�?&quot;">​</a></h3><h4 id="先更新数据库-再更新缓存" tabindex="-1"><strong>先更新数据库，再更新缓存</strong> <a class="header-anchor" href="#先更新数据库-再更新缓存" aria-label="Permalink to &quot;**先更新数据库，再更新缓存**&quot;">​</a></h4><p><strong>线程安全</strong>：同时有请求A和请求B进行更新操作</p><blockquote><ol><li>线程A更新了数据库</li><li>线程B更新了数据库</li><li>线程B更新了缓�?</li><li>线程A更新了缓�?</li></ol></blockquote><p>这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑</p><p><strong>业务场景</strong>：（1）如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能；（2）如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合</p><h4 id="先删除缓存-再更新数据库" tabindex="-1"><strong>先删除缓存，再更新数据库</strong> <a class="header-anchor" href="#先删除缓存-再更新数据库" aria-label="Permalink to &quot;**先删除缓存，再更新数据库**&quot;">​</a></h4><blockquote><ol><li>请求A进行写操作，删除缓存</li><li>请求B查询发现缓存不存�?</li><li>请求B去数据库查询得到旧�?</li><li>请求B将旧值写入缓�?</li><li>请求A将新值写入数据库</li></ol></blockquote><p>上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据�?</p><h4 id="先更新数据库-再删除缓存" tabindex="-1"><strong>先更新数据库，再删除缓存</strong> <a class="header-anchor" href="#先更新数据库-再删除缓存" aria-label="Permalink to &quot;**先更新数据库，再删除缓存**&quot;">​</a></h4><blockquote><ol><li>请求缓存刚好失效</li><li>请求A查询数据库，得一个旧�?</li><li>请求B将新值写入数据库</li><li>请求B删除缓存</li><li>请求A将查到的旧值写入缓�?</li></ol></blockquote><p>这样就出现脏数据了，然而，实际上出现的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，而又要晚于写操作删除缓存，所有的这些条件都具备的概率基本并不大，但是还是会有出现的概率。并且假�?<em>第一步写数据库成功，第二步删除缓存失败，这样也导致脏数据</em>*</p><h4 id="延时双删" tabindex="-1"><strong>延时双删</strong> <a class="header-anchor" href="#延时双删" aria-label="Permalink to &quot;**延时双删**&quot;">​</a></h4><blockquote><ol><li>先删�?淘汰)缓存</li><li>再写数据库（这两步和原来一样）</li><li>休眠1秒，再次删除(淘汰)缓存</li></ol></blockquote><p>或�?</p><blockquote><ol><li>先写数据�?</li><li>再删�?淘汰)缓存（这两步和原来一样）</li><li>休眠1秒，再次删除(淘汰)缓存</li></ol></blockquote><p>这个1秒应该看你的业务场景，应该自行评估自己的项目的读数据业务逻辑的耗时，然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可，这么做确保读请求结束，写请求可以删除读请求造成的缓存脏数据</p><p><strong>为了性能更快，可以把第二次删除缓存可以做成异步的，这样不会阻塞请求了，如果再严谨点，防止第二次删除缓存失败，这个异步删除缓存可以加上重试机制，失败一直重试，直到成功</strong></p><p><strong>方案一</strong></p><blockquote><ol><li>更新数据库数�?</li><li>缓存因为种种问题删除失败</li><li>将需要删除的key发送至消息队列</li><li>自己消费消息，获得需要删除的key</li><li>继续重试删除操作，直到成�?</li></ol></blockquote><p><img src="https://i.loli.net/2021/08/23/9rzmXuUeYCcOGQp.jpg" alt="9rzmXuUeYCcOGQp"></p><p>该方案有一个缺点，对业务线代码造成大量的侵入，于是有了方案二，启动一个订阅程序去订阅数据库的Binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作</p><p>*<em>方案�?</em></p><blockquote><ol><li>更新数据库数�?</li><li>数据库会将操作信息写入binlog日志当中</li><li>订阅程序提取出所需要的数据以及key</li><li>另起一段非业务代码，获得该信息</li><li>尝试删除缓存操作，发现删除失�?</li><li>将这些信息发送至消息队列</li><li>重新从消息队列中获得该数据，重试操作</li></ol></blockquote><p><img src="https://i.loli.net/2021/08/23/WcMTS4zq9A7E8sD.jpg" alt="WcMTS4zq9A7E8sD"></p><h3 id="_7-redis-的内存淘汰策�" tabindex="-1">7.<code>redis</code> 的内存淘汰策�? <a class="header-anchor" href="#_7-redis-的内存淘汰策�" aria-label="Permalink to &quot;7.`redis` 的内存淘汰策�?&quot;">​</a></h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtbx2jwtfnj61ct0l9dhm02.jpg" alt=""></p><ul><li><p><code>volatile-ttl</code> 在筛选时会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删�?</p></li><li><p><code>volatiile-random</code> 在筛选时对设置了过期时间的键值对进行随机删除</p></li><li><p><code>volatile-lru</code> 使用 <code>lru</code> 算法筛选设置了过期时间的键值对</p></li><li><p><code>volatile-lfu</code> 使用 <code>lfu</code> 算法筛选设置了过期时间的键值对</p></li><li><p>优先使用 <code>allkeys-lru</code> 可以充分利用 <code>lru</code> 这一经典算法的优势，把最近最常访问的数据留在缓存中，提升应用的访问性能</p></li><li><p>如果业务中有置顶的需求，可以使用 <code>volatile-lru</code> 策略同时不给这些置顶数据设置过期时间</p></li></ul><h3 id="_8-redis-�-key-的过期策�" tabindex="-1">8.<code>redis</code> �?<code>key</code> 的过期策�? <a class="header-anchor" href="#_8-redis-�-key-的过期策�" aria-label="Permalink to &quot;8.`redis` �?`key` 的过期策�?&quot;">​</a></h3><ul><li><p><strong>定时过期</strong>：每个设置过期时间的<code>key</code>都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的<code>CPU</code>资源去处理过期的数据，从而影响缓存的响应时间和吞吐量</p></li><li><p>**惰性过�?*：只有当访问一个<code>key</code>时，才会判断该<code>key</code>是否已过期，过期则清除。该策略可以最大化地节省<code>CPU</code>资源，却对内存非常不友好。极端情况可能出现大量的过期<code>key</code>没有再次被访问，从而不会被清除，占用大量内�?</p></li><li><p><strong>定期过期</strong>：每隔一定的时间，会扫描一定数量的数据库的<code>expires</code>字典中一定数量的<code>key</code>，并清除其中已过期的<code>key</code>。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果</p></li></ul><h3 id="_9-redis-是单线程的吗-为什么这么快" tabindex="-1">9.<code>redis</code> 是单线程的吗，为什么这么快 <a class="header-anchor" href="#_9-redis-是单线程的吗-为什么这么快" aria-label="Permalink to &quot;9.`redis` 是单线程的吗，为什么这么快&quot;">​</a></h3><p>*<em>单线�?</em></p><ul><li>没有了多线程上下文切换的性能损�?</li><li>没有了访问共享资源加锁的性能损�?</li><li>开发和调试非常友好，可维护性高</li></ul><p>*<em>纯内存操�?</em></p><p><code>redis</code>是一个内存数据库，它的数据都存储在内存中，这意味着我们读写数据都是在内存中完成，这个速度是非常快的。<code>redis</code>是一个KV内存数据库，它内部构建了一个哈希表，根据指定的<code>KEY</code>访问时，只需要<code>O(1)</code>的时间复杂度就可以找到对应的数据。同时，<code>redis</code>提供了丰富的数据类型，并使用高效的操作方式进行操作，这些操作都在内存中进行，并不会大量消耗<code>CPU</code>资源，所以速度极快</p><p>*<em>IO 多路复用技�?</em></p><p><code>redis</code> 服务采用 <code>Reactor</code> 的方式来实现文件事件处理器（每一个网络连接其实都对应一个文件描述符）。文件事件处理器使用 I/O 多路复用模块同时监听多个 FD，当 <code>accept</code>、<code>read</code>、<code>write</code> �?<code>close</code> 文件事件产生时，文件事件处理器就会回�?FD 绑定的事件处理器。虽然整个文件事件处理器是在单线程上运行的，但是通过 I/O 多路复用模块的引入，实现了同时对多个 FD 读写的监控，提高了网络通信模型的性能，同时也可以保证整个 <code>redis</code> 服务实现的简�?</p><h3 id="参�" tabindex="-1">参�? <a class="header-anchor" href="#参�" aria-label="Permalink to &quot;参�?&quot;">​</a></h3><ul><li><a href="https://blog.csdn.net/Liu_Wd/article/details/108052428" target="_blank" rel="noreferrer">https://blog.csdn.net/Liu_Wd/article/details/108052428</a></li><li><a href="https://zhuanlan.zhihu.com/p/366972218" target="_blank" rel="noreferrer">https://zhuanlan.zhihu.com/p/366972218</a></li><li><a href="https://houbb.github.io/2019/01/02/db-index-07-combine-index" target="_blank" rel="noreferrer">https://houbb.github.io/2019/01/02/db-index-07-combine-index</a></li><li><a href="https://juejin.cn/post/6860252224930070536" target="_blank" rel="noreferrer">https://juejin.cn/post/6860252224930070536</a></li><li><a href="https://redisbook.readthedocs.io/en/latest/internal-datastruct/skiplist.html" target="_blank" rel="noreferrer">https://redisbook.readthedocs.io/en/latest/internal-datastruct/skiplist.html</a></li><li><a href="https://www.jianshu.com/p/53f0b27dc7e1" target="_blank" rel="noreferrer">https://www.jianshu.com/p/53f0b27dc7e1</a></li><li><a href="https://sourcegraph.com/github.com/Wasabi1234/Java-Interview-Tutorial/-/blob/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96.md" target="_blank" rel="noreferrer">https://sourcegraph.com/github.com/Wasabi1234/Java-Interview-Tutorial/-/blob/数据存储/Redis/Redis持久化.md</a></li><li><a href="https://www.cnblogs.com/kismetv/p/9236731.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/kismetv/p/9236731.html</a></li><li><a href="https://java.isture.com/redis/question/Redis%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E6%97%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7.html" target="_blank" rel="noreferrer">https://java.isture.com/redis/question/Redis保证缓存与数据库双写时的数据一致性.html</a></li><li><a href="https://www.jianshu.com/p/8aa619933ebb" target="_blank" rel="noreferrer">https://www.jianshu.com/p/8aa619933ebb</a></li></ul>',212))])}const y=l(c,[["render",s]]);export{b as __pageData,y as default};
