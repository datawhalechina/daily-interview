# è´ªå¿ƒç®—æ³•
> æ˜¯æ¯æ¬¡åªè€ƒè™‘å½“å‰æœ€ä¼˜ï¼Œç›®æ ‡è¯æ˜æ¯æ¬¡æ˜¯è€ƒè™‘å½“å‰æœ€ä¼˜èƒ½å¤Ÿè¾¾åˆ°å±€éƒ¨æœ€ä¼˜ï¼Œè¿™å°±æ˜¯è´ªå¿ƒçš„æ€æƒ³ï¼Œä¸€èˆ¬æƒ…å†µä¸‹è´ªå¿ƒå’Œæ’åºä¸€èµ·å‡ºç°ï¼Œéƒ½æ˜¯å…ˆæ ¹æ®æ¡ä»¶è¿›è¡Œæ’åºï¼Œä¹‹ååŸºäºè´ªå¿ƒç­–ç•¥å¾—åˆ°æœ€ä¼˜ç»“æœã€?
> é¢è¯•çš„æ—¶å€™é¢è¯•å®˜ä¸€èˆ¬ä¸ä¼šå‡ºè´ªå¿ƒç®—æ³•ï¼Œå¦‚æœå¯èƒ½è´ªå¿ƒä¸€èˆ¬éƒ½å¯ä»¥ä½¿ç”¨åŠ¨æ€è§„åˆ’è§£å†³ï¼Œé¢è¯•å®˜å¾ˆå–œæ¬¢å‡ºåŠ¨æ€è§„åˆ’çš„é¢˜ç›®ã€?

## 1. æœ€å¤§è¿ç»­å­åºåˆ—
> **é¢˜ç›®**: ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼Œæ‰¾åˆ°ä¸€ä¸ªå…·æœ‰æœ€å¤§å’Œçš„å­æ•°ç»„ï¼Œè¿”å›å…¶æœ€å¤§å’Œã€?   
> **æ‰©å±•1**: ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼Œæ‰¾å‡ºä¸¤ä¸ª ä¸é‡å?å­æ•°ç»„ä½¿å¾—å®ƒä»¬çš„å’Œæœ€å¤§ã€?    
> **æ‰©å±•2**: ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼Œæ‰¾å‡ºä¸¤ä¸ªä¸é‡å çš„å­æ•°ç»„Aå’ŒBï¼Œä½¿ä¸¤ä¸ªå­æ•°ç»„å’Œçš„å·®çš„ç»å¯¹å€¼|SUM(A) - SUM(B)|æœ€å¤§ã€?       
> **åˆ†æ**: ä½¿ç”¨è¿™ä¸ªsè¡¨ç¤ºå½“å‰å¯èƒ½æ»¡è¶³çš„æœ€å¤§å’Œï¼Œå¦‚æœs>0,æˆ‘ä»¬è®¤ä¸ºså¯¹æ¥ä¸‹æ¥çš„åŠ æ“ä½œæœ‰å¸®åŠ©ï¼ŒåŸºäºs+=nums[i]ï¼Œif s < 0, è®¤ä¸ºsåªä¼šå¯¹åé¢é€ æˆè´Ÿå½±å“ï¼Œä¸¤s=nums[i]ã€?     
> **æ‰©å±•é—®é¢˜**: å¯ä»¥å°?æ•°ç»„ä»æ¯ä¸ªä½ç½®kåˆ†å¼€ï¼Œåˆ†åˆ«ç»“ç®—[1,i]å’Œ[i+1, n)çš„æœ€å€¼ï¼Œè®°å½•çš„è¿‡ç¨‹ä¸­å¯ä»¥ä½¿ç”¨æ•°ç»„ä¿å­˜ä¸‹æ¥çš„å·²ç»è®¡ç®—å¥½çš„å€¼ã€?
```
int maxSubArray(vector<int> &nums) {
    int s = 0, ans = -1000000;
    for(int i = 0; i < nums.size(); i ++) {
        if(s > 0) s += nums[i];
        else s = nums[i];
        ans = max(s, ans);
    }
    return ans;
}
```
## 2. åˆ é™¤æ•°å­—
> **é¢˜ç›®**: ç»™å®šä¸€ä¸ªä»¥å­—ç¬¦ä¸²è¡¨ç¤ºçš„éè´Ÿæ•´æ•°ï¼Œä»è¯¥æ•°å­—ä¸­ç§»é™¤æ‰kä¸ªæ•°ä½ï¼Œè®©å‰©ä½™æ•°ä½ç»„æˆçš„æ•°å­—å°½å¯èƒ½å°ï¼Œæ±‚å¯èƒ½çš„æœ€å°ç»“æœã€?  
> **åˆ†æ**: ä»å·¦åˆ°å³éå†å­—ç¬¦ä¸²ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªä¸æ»¡è¶³é€’å¢çš„æ•°å­—åˆ é™¤ï¼Œä¸€å®šä¼šä¿è¯å½“å‰æ“ä½œä¹‹åå‰©ä¸‹çš„æ•°å­—æœ€å°ã€?
```
string removeKdigits(string &num, int k) {
    int i;
    while(k --) {
        for(i = 0; i < num.size() - 1 && num[i] <= num[i+1]; i ++);
        num.erase(num.begin() + i);
    }
    // remove 0
    auto it = num.begin();
    while(it != num.end() && *it == '0') {
        num.erase(it);
        it = num.begin();
    }
    if(num.size() == 0) num = "0";
    return num;
}

```
## 3. æ— é‡å åŒºé—?
> **é¢˜ç›®**: ç»™å®šä¸€äº›åŒºé—´ï¼Œæ‰¾åˆ°éœ€è¦ç§»é™¤çš„æœ€å°åŒºé—´æ•°ï¼Œä»¥ä½¿å…¶ä½™çš„åŒºé—´ä¸é‡å ã€?     
> **åˆ†æ**: è´ªå¿ƒä¸€èˆ¬ä¼´éšç€æ’åºä¸€èµ·å‡ºç°ï¼Œæˆ‘ä»¬æ ¹æ®åŒºé—´çš„ç»“æŸä½¿ç”¨å‡åºæ’åºï¼Œä¹‹åè¿›è¡Œéå†ï¼Œå¦‚æœå‘ç°ä¸æ»¡è¶³æ¡ä»¶ï¼Œåˆ™ç§»é™¤è¿™ä¸ªä¸æ»¡è¶³çš„åŒºé—´ã€?
```
classs Interval {
    int start, end;
    Interval(int start, int end) {
        this->start = start;
        this->end = end;
    }
}
bool cmp(Interval a, Interval b) {
    if(a.end < b.end) return 1;
    else return 0;
}     
int eraseOverlapIntervals(vector<Interval> &intervals) {
    sort(intervals.begin(), intervals.end(), cmp);    
    int cnt = 0;
    Interval tmp = intervals[0];
    for(int i = 1; i < intervals.size(); i ++) {
        if(tmp.end <= intervals[i].start) tmp = intervals[i];
        else {
            cnt ++;
        }
    }
    return cnt;
}
```
## 4. åˆå¹¶æ•°å­—
> **é¢˜ç›®**: ç»™å‡ºnä¸ªæ•°ï¼Œç°åœ¨è¦å°†è¿™nä¸ªæ•°åˆå¹¶æˆä¸€ä¸ªæ•°ï¼Œæ¯æ¬¡åªèƒ½é€‰æ‹©ä¸¤ä¸ªæ•°a,båˆå¹¶ï¼Œæ¯æ¬¡åˆå¹¶éœ€è¦æ¶ˆè€—a+bçš„èƒ½é‡ï¼Œè¾“å‡ºå°†è¿™nä¸ªæ•°åˆå¹¶æˆä¸€ä¸ªæ•°åæ¶ˆè€—çš„æœ€å°èƒ½é‡ã€?  
> **åˆ†æ**: å‚è€ƒå“ˆå¤«æ›¼æ ‘çš„æ„é€ ï¼Œæ¯ä¸€æ¬¡åˆå¹¶ä¸¤ä¸ªæœ€å°çš„æ•°ï¼Œç›´åˆ°å‰©ä¸‹ä¸€ä¸ªæ•°å­—ï¼Œå› ä¸ºæ¯æ¬¡è¦é€‰æ‹©ä¸¤ä¸ªæœ€å°çš„ï¼Œéœ€è¦ç”¨åˆ°æœ€å°å †æ¥å®ç°ï¼Œå¯ä»¥ä½¿ç”¨C++SLTä¸­çš„ä¼˜å…ˆé˜Ÿåˆ—.
> æ ¹æ®è¿™ä¸ªé¢˜ç›®ï¼Œè¯·å¤§å®¶**è‡ªè¡Œè¡¥ä¸Šå“ˆå¤«æ›¼æ ‘**ã€?
```
int mergeNumber(vector<int> &numbers) {
    priority_queue<int, vector<int>, greater<int>> pq;
    for(int i = 0; i < numbers.size(); i ++) {
        pq.push(numbers[i]);
    }
    int cost = 0;
    while(pq.size() > 1) {
        int a = pq.top();
        pq.pop();
        int b = pq.top();
        pq.pop();
        cost += (a + b);
        pq.push(a + b);
    }
    return cost;
}

```
## 5. æœ€å°æ”¯æ’‘æ ‘
> é¢˜ç›®: ä½¿ç”¨kruskalç®—æ³•ï¼Œæ„é€ æœ€å°æ”¯æ’‘æ ‘ã€?
> åˆ†æ: è¯¦è§ç™¾åº¦ç™¾ç§‘æˆ–è€…wikipedia.       
> ä»£ç : <a href="https://www.geeksforgeeks.org/kruskals-minimum-spanning-tree-algorithm-greedy-algo-2/">kruskal code</a>
```
struct Edge { 
    int src, dest, weight; 
}; 
struct Graph { 
    int V, E;   
    struct Edge* edge; 
}; 
struct Graph* createGraph(int V, int E) { 
    struct Graph* graph = new Graph; 
    graph->V = V; 
    graph->E = E;   
    graph->edge = new Edge[E]; 
    return graph; 
} 
struct subset { 
    int parent; 
    int rank; 
}; 
int find(struct subset subsets[], int i) { 
    if (subsets[i].parent != i) 
        subsets[i].parent = find(subsets, subsets[i].parent); 
    return subsets[i].parent; 
} 
void Union(struct subset subsets[], int x, int y) { 
    int xroot = find(subsets, x); 
    int yroot = find(subsets, y);   
    if (subsets[xroot].rank < subsets[yroot].rank) 
        subsets[xroot].parent = yroot; 
    else if (subsets[xroot].rank > subsets[yroot].rank) 
        subsets[yroot].parent = xroot;   
    else { 
        subsets[yroot].parent = xroot; 
        subsets[xroot].rank++; 
    } 
} 
int myComp(const void* a, const void* b) { 
    struct Edge* a1 = (struct Edge*)a; 
    struct Edge* b1 = (struct Edge*)b; 
    return a1->weight > b1->weight; 
} 
void KruskalMST(struct Graph* graph) { 
    int V = graph->V; 
    struct Edge result[V];  
    int e = 0; 
    int i = 0; 
    qsort(graph->edge, graph->E, sizeof(graph->edge[0]), myComp);   
    struct subset *subsets = 
        (struct subset*) malloc( V * sizeof(struct subset) ); 
    for (int v = 0; v < V; ++v) { 
        subsets[v].parent = v; 
        subsets[v].rank = 0; 
    }   
    while (e < V - 1) { 
        struct Edge next_edge = graph->edge[i++];   
        int x = find(subsets, next_edge.src); 
        int y = find(subsets, next_edge.dest);   
        if (x != y) { 
            result[e++] = next_edge; 
            Union(subsets, x, y); 
        } 
    }   
    return; 
} 
```
## 6. è¡¥é½æ•°ç»„
> é¢˜ç›®: ç»™å‡ºä¸€ä¸ªæ­£æ•´æ•°æ•°ç»„numså’Œä¸€ä¸ªæ•´æ•°nï¼Œå‘æ•°ç»„æ·»åŠ patchå…ƒç´ ï¼Œä½¿å¾—èŒƒå›´[1, n]åŒ…å«çš„ä»»ä½•æ•°å­—éƒ½å¯ä»¥ç”±æ•°ç»„ä¸­æŸäº›å…ƒç´ çš„æ€»å’Œå½¢æˆã€‚è¿”å›æ‰€éœ€çš„æœ€å°‘è¡¥é½æ•°ã€?       
> åˆ†æï¼?
> 1. å‡åºæ’åºï¼?
> 2. ä½¿ç”¨rè¡¨ç¤ºç›®å‰å¯ä»¥è¡¨ç¤ºçš„å³è¾¹ç•Œï¼Œå¦‚æœå½“å‰å€?> r, è¶…å‡ºèŒƒå›´ï¼Œåˆå› ä¸º [1, n] åŒºé—´å†…çš„ä»»ä½•æ•°å­—éƒ½å¯ä»¥ç”¨ nums ä¸­æŸå‡ ä¸ªæ•°å­—çš„å’Œæ¥è¡¨ç¤ºï¼Œé‚£ä¹ˆåªéœ€è¦æœ‰n/2ä»¥åŠ [1, n/2] åŒºé—´å†…ä»»ä½•æ•°å­—éƒ½å¯ä»¥ç”?nums ä¸­æŸå‡ ä¸ªæ•°å­—çš„å’Œæ¥è¡¨ç¤ºå³å¯ã€‚æ‰€æœ‰æˆ‘ä»¬å°†ræ‰©å¤§ä¸€å€ï¼Œç»§ç»­åˆ¤æ–­æ˜¯å¦æ»¡è¶³ã€?
> 3. ç›´åˆ° r >= nã€?
```
int minPatches(vector<int> &nums, int n) {
    sort(nums.begin(), nums.end());
    long long r = 1;
    int i = 0;
    int cnt = 0;
    while(r <= n) {
        if(i < nums.size() && nums[i] <= r) r += nums[i++];
        else {
            cnt ++;
            r *= 2;
        }
    }
    return cnt;
}
```

## 7. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœ?
> é¢˜ç›®: å‡è®¾æœ‰ä¸€ä¸ªæ•°ç»„ï¼Œå®ƒçš„ç¬¬iä¸ªå…ƒç´ æ˜¯ä¸€æ”¯ç»™å®šçš„è‚¡ç¥¨åœ¨ç¬¬iå¤©çš„ä»·æ ¼ã€‚å¦‚æœä½ æœ€å¤šåªå…è®¸å®Œæˆä¸€æ¬¡äº¤æ˜?ä¾‹å¦‚,ä¸€æ¬¡ä¹°å–è‚¡ç¥?,è®¾è®¡ä¸€ä¸ªç®—æ³•æ¥æ‰¾å‡ºæœ€å¤§åˆ©æ¶¦ã€?   
> åˆ†æ: å…ˆä½ä»·ä¹°å…¥ï¼Œå†é«˜ä»·å–å‡ºï¼Œå› æ­¤ä»å‰å‘åï¼Œè®°å½•æœ€å°å€¼å¹¶ä¸”æ›´æ–°æœ€æœ‰ç»“æœï¼Œ

```
int maxProfit(vector<int> &prices) {
    int minp = prices[0];
    int ans = 0;
    for(int i = 1; i < prices.size(); i ++) {
        ans = max(ans, prices[i] - minp);
        minp = min(minp, prices[i]);
    }
    return ans;
}
```
## 8. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºII
> **é¢˜ç›®**: å‡è®¾æœ‰ä¸€ä¸ªæ•°ç»„ï¼Œå®ƒçš„ç¬¬iä¸ªå…ƒç´ æ˜¯ä¸€ä¸ªç»™å®šçš„è‚¡ç¥¨åœ¨ç¬¬iå¤©çš„ä»·æ ¼ã€‚è®¾è®¡ä¸€ä¸ªç®—æ³•æ¥æ‰¾åˆ°æœ€å¤§çš„åˆ©æ¶¦ã€‚ä½ å¯ä»¥å®Œæˆå°½å¯èƒ½å¤šçš„äº¤æ˜?å¤šæ¬¡ä¹°å–è‚¡ç¥¨)ã€‚ç„¶è€?ä½ ä¸èƒ½åŒæ—¶å‚ä¸å¤šä¸ªäº¤æ˜?ä½ å¿…é¡»åœ¨å†æ¬¡è´­ä¹°å‰å‡ºå”®è‚¡ç¥?ã€?    
> **åˆ†æ**: å¤šæ¬¡ä¹°å–ï¼Œæˆ‘ä»¬å¯ä»¥å°½å¯èƒ½å¤šçš„ä¹°å–è‚¡ç¥¨ï¼Œå¦‚æœæ»¡è¶³prices[i+1] > price[i]ï¼Œå°±è¿›è¡Œä¸€æ¬¡ä¹°å–ï¼Œå…¶å®æˆ‘ä»¬çŸ¥é“å¦‚æœæ˜¯ä¸€ä¸ªé€’å¢åºåˆ—ï¼?prices[i+1] - prices[i]) + (prices[i] - prices[i-1]) = prices[i+1] - prices[i]ï¼Œå¯ä»¥ä¿è¯æˆ‘ä»¬å°†æ‰€æœ‰å¯èƒ½çš„ä¹°å–è¯†åˆ«å‡ºæ¥ã€?

```
int maxProfit(vector<int> &prices) {
    int sum = 0;
    for(int i=1;i<prices.size();i++){
        if(prices[i] > prices[i-1]){
            sum += prices[i] - prices[i-1];
        }
    }
    return sum;
}
```
## 9. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºå«æ‰‹ç»­è´?
> **é¢˜ç›®**: ç»™å®šä¸€ä¸ªæ•°ç»„ï¼Œå…¶ä¸­ç¬¬iä¸ªå…ƒç´ æ˜¯ä¸€æ”¯è‚¡ç¥¨åœ¨ç¬¬iå¤©çš„ä»·æ ¼ï¼Œä»¥åŠä¸€ä¸ªéè´Ÿæ•° fee ä»£è¡¨äº†äº¤æ˜“æ‰‹ç»­è´¹ã€‚ï¼ˆåªéœ€è¦åœ¨å–å‡ºæ—¶æ”¯ä»?feeï¼‰ã€‚ä½ å¯ä»¥è¿›è¡Œä»»æ„æ¬¡äº¤æ˜“ï¼Œè€Œæ¯æ¬¡äº¤æ˜“éƒ½å¿…é¡»ä»˜æ‰‹ç»­è´¹ï¼Œè€Œä¸”ä½ ä¸èƒ½æŒæœ‰è¶…è¿?æ”¯æ•°é‡çš„è‚¡ç¥¨ï¼ˆä¹Ÿå°±æ˜¯è¯´ï¼Œä½ åœ¨ä¹°å…¥ä¹‹å‰éœ€è¦å…ˆæŠŠä¹‹å‰ä¹°å…¥çš„å–å‡ºï¼‰ã€‚è¿”å›å¯ä»¥è·å¾—çš„æœ€å¤§åˆ©æ¶¦ã€?     
> **åˆ†æ**: 
> + æˆ‘ä»¬è€ƒè™‘æœ€æœ´ç´ çš„æ–¹æ³•ï¼Œå¯¹äºæ¯ä¸€å¤©ï¼Œå¦‚æœå½“å‰æœ‰è‚¡ç¥¨ï¼Œè€ƒè™‘å‡ºå”®æˆ–è€…ä¿ç•™ï¼Œå¦‚æœæ²¡è‚¡ç¥¨ï¼Œè€ƒè™‘è´­ä¹°æˆ–è€…è·³è¿‡ï¼Œè¿›è¡Œdfsæœç´¢ã€‚æ¯å¤©éƒ½æœ‰ä¸¤ç§æ“ä½œï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºO(2^n).
> + å¦‚ä½•ä¼˜åŒ–å‘¢ï¼Ÿæˆ‘ä»¬ç”¨åŠ¨æ€è§„åˆ’çš„æ€æƒ³æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œè€ƒè™‘æ¯ä¸€å¤©åŒæ—¶ç»´æŠ¤ä¸¤ç§çŠ¶æ€ï¼šæ‹¥æœ‰è‚¡ç¥¨(own)çŠ¶æ€å’Œå·²ç»å”®å‡ºè‚¡ç¥¨(sell)çŠ¶æ€ã€‚ç”¨ownå’Œsellåˆ†åˆ«ä¿ç•™è¿™ä¸¤ç§çŠ¶æ€åˆ°ç›®å‰ä¸ºæ­¢æ‰€æ‹¥æœ‰çš„æœ€å¤§åˆ©æ¶¦ã€?å¯¹äºsellï¼Œç”¨å‰ä¸€å¤©ownçŠ¶æ€è½¬ç§»ï¼Œæ¯”è¾ƒå–å‡ºæŒæœ‰è‚¡æ˜¯å¦èƒ½å¾—åˆ°æ›´å¤šçš„åˆ©æ¶¦ï¼Œå³sell = max(sell , own + price - fee)ï¼?è€Œå¯¹äºown , æˆ‘ä»¬è€ƒè™‘æ˜¯å¦ä¹°æ–°çš„è‚¡ç¥¨æ›´èƒ½èµšé’?æ¢è¨€ä¹‹ï¼Œæ›´ä¼˜æƒ ï¼‰ï¼Œown=max( own, sell-price).
> + åˆå§‹åŒ–æˆ‘ä»¬è¦æŠŠsellè®¾ä¸º0è¡¨ç¤ºæœ€åˆæ˜¯sellçŠ¶æ€ä¸”æ²¡æœ‰profitï¼ŒæŠŠownè®¾ä¸ºè´Ÿæ— ç©·å› ä¸ºæœ€åˆä¸å­˜åœ¨è¯¥çŠ¶æ€ï¼Œæˆ‘ä»¬ä¸å¸Œæœ›ä»è¿™ä¸ªçŠ¶æ€è¿›è¡Œè½¬ç§?
> + å› ä¸ºæˆ‘ä»¬ä¿å­˜çš„éƒ½æ˜¯æœ€ä¼˜çŠ¶æ€ï¼Œæ‰€ä»¥åœ¨ä¹°å–è‚¡ç¥¨æ—¶å€™å–maxèƒ½ä¿è¯æœ€ä¼˜æ€§ä¸å?
> + æœ€åç›´æ¥è¿”å›sellå³å¯. 
> + æ¥è‡ª(https://www.jiuzhang.com/solution/best-time-to-buy-and-sell-stock-with-transaction-fee/#tag-highlight-lang-cpp)

```
int maxProfit(vector<int> &prices, int fee) {
    int sell = 0, buy = -prices[0];
    for (int price : prices) {
        int sellOld = sell;
        sell = max(sell, buy + price - fee);
        buy = max(buy, sellOld - price);
    }
    return sell;
}
```

## 10. æœ€åçš„çŒ?
> **é¢˜ç›®**: ç»™ä½ ä¸€ä¸ªnåªçŒ«ï¼Œæ¯ä¸€ä¸ªçŒ«éƒ½æœ‰ä¸€ä¸ªåˆå§‹åŒ–çš„èŒç³»æ•°ï¼Œå½“ä¸€åªçŒ«çš„èŒç³»æ•°å˜æˆ0å®ƒå°±ä¼šç¦»å¼€ä½ ã€‚ç°åœ¨ä½ å®åœ¨å—ä¸äº†è¿™nåªèŒçŒ«ï¼Œæƒ³è¦åªç•™ä¸‹ä¸€åªçŒ«ï¼Œå¹¶ä¸”ä½¿å®ƒçš„èŒç³»æ•°æœ€ä½ã€‚æ¯ä¸€ä¸ªä½ å¯ä»¥é€‰æ‹©ä»»æ„ä¸€åªçŒ«Aå»æ¶ˆè€—å¦å¤–ä¸€åªçŒ«Bçš„èŒç³»æ•°ï¼Œè¿™æ ·çš„è¯çŒ«Bçš„èŒç³»æ•°å°±ä¼šå‡å»çŒ«Açš„èŒç³»æ•°ï¼Œå½“çŒ«Açš„èŒç³»æ•°ä¸å˜ã€‚é€šè¿‡å¤šæ¬¡å›åˆä¹‹åï¼Œæœ€åå‰©ä¸‹çš„çŒ«çš„èŒç³»æ•°æœ€å°æ˜¯å¤šå°‘ã€?   
> **åˆ†æ**: æˆ‘ä»¬çš„ç›®çš„æ˜¯ç•™ä¸‹ä¸€åªçŒ«ï¼Œä½¿å®ƒçš„èŒç³»æ•°æœ€å°ï¼Œä»è¿™ä¸ªè§’åº¦å‡ºå‘ï¼Œæˆ‘ä»¬å¯ä»¥é€‰æ‹©æœ€å°èŒç³»æ•°çš„çŒ«ï¼Œå»æ¶ˆè€—å…¶ä»–çš„çŒ«ï¼Œå¦‚æœå…¶ä»–çš„çŒ«èŒç³»æ•°å˜æˆ?ï¼Œå°±ç¦»å¼€äº†ã€‚ä¾‹å¦‚æœ€å°èŒç³»æ•°çš„çŒ«çš„ç³»æ•°æ˜¯aï¼Œå¯¹äºå…¶ä»–çš„çŒ«ï¼Œå¦‚æœb%a == 0ï¼Œåˆ™ç»è¿‡å¤šæ¬¡æ¶ˆè€—ä¹‹åï¼Œbå°±ä¼šç¦»å¼€ï¼Œå¦‚æœb%a!=0, åˆ™ç»“æœæ˜¯ç»è¿‡å¤šè½®æ¶ˆè€—ä¹‹åå˜æˆ?b%a, a)ï¼Œç›´åˆ°ä¸€æ–¹å˜æˆ?ï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°è¿™æ˜¯ä¸€ä¸ªæ±‚æœ€å¤§å…¬çº¦çš„ç®—å¼ã€‚å› æ­¤ï¼Œæœ€åçš„çŒ«èŒç³»æ•°æ˜¯gcd(h[0],h[0],...,h[n-1]);

```
int gcd(int a, int b) {
    if(a == 0) return b;
    return gcd(b % a, a);
}
int solve(vector<int> &h) {
    if(h.size() == 1) return h[0];
    int ans = gcd(h[0], h[1]);
    for(int i = 2; i < h.size(); i ++) {
        ans = gcd(ans, h[i]);
    }
    return ans;
}
```cpp