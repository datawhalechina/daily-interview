<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>贪心算法 | Daily Interview - 面试必看</title>
    <meta name="description" content="每一个面试者面试之前必看一遍的小面经">
    <meta name="generator" content="VitePress v1.6.4">
    <link rel="preload stylesheet" href="/daily-interview/assets/style.CZXOQdG2.css" as="style">
    <link rel="preload stylesheet" href="/daily-interview/vp-icons.css" as="style">
    
    <script type="module" src="/daily-interview/assets/app.dMbZkfcD.js"></script>
    <link rel="preload" href="/daily-interview/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/daily-interview/assets/chunks/theme.Bqjks9on.js">
    <link rel="modulepreload" href="/daily-interview/assets/chunks/framework.DT5BmYxR.js">
    <link rel="modulepreload" href="/daily-interview/assets/01-algorithm-basics_algorithm-concepts_greedy-algorithms.md.bZiiPNdo.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-5d98c3a5><!--[--><!--]--><!--[--><span tabindex="-1" data-v-0b0ada53></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-0b0ada53>Skip to content</a><!--]--><!----><header class="VPNav" data-v-5d98c3a5 data-v-ae24b3ad><div class="VPNavBar" data-v-ae24b3ad data-v-6aa21345><div class="wrapper" data-v-6aa21345><div class="container" data-v-6aa21345><div class="title" data-v-6aa21345><div class="VPNavBarTitle has-sidebar" data-v-6aa21345 data-v-1168a8e4><a class="title" href="/daily-interview/" data-v-1168a8e4><!--[--><!--]--><!----><span data-v-1168a8e4>Daily Interview - 面试必看</span><!--[--><!--]--></a></div></div><div class="content" data-v-6aa21345><div class="content-body" data-v-6aa21345><!--[--><!--]--><div class="VPNavBarSearch search" data-v-6aa21345><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-6aa21345 data-v-dc692963><span id="main-nav-aria-label" class="visually-hidden" data-v-dc692963> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/daily-interview/" tabindex="0" data-v-dc692963 data-v-e56f3d57><!--[--><span data-v-e56f3d57>首页</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/daily-interview/01-algorithm-basics/" tabindex="0" data-v-dc692963 data-v-e56f3d57><!--[--><span data-v-e56f3d57>算法基础</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/daily-interview/02-programming-languages/" tabindex="0" data-v-dc692963 data-v-e56f3d57><!--[--><span data-v-e56f3d57>编程语言</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/daily-interview/03-computer-basics/" tabindex="0" data-v-dc692963 data-v-e56f3d57><!--[--><span data-v-e56f3d57>计算机基础</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/daily-interview/04-ai-algorithms/" tabindex="0" data-v-dc692963 data-v-e56f3d57><!--[--><span data-v-e56f3d57>AI算法</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/daily-interview/05-system-design/" tabindex="0" data-v-dc692963 data-v-e56f3d57><!--[--><span data-v-e56f3d57>系统设计</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/daily-interview/06-development-tech/" tabindex="0" data-v-dc692963 data-v-e56f3d57><!--[--><span data-v-e56f3d57>开发技术</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/daily-interview/07-project-experience/" tabindex="0" data-v-dc692963 data-v-e56f3d57><!--[--><span data-v-e56f3d57>项目经验</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/daily-interview/08-behavioral-interview/" tabindex="0" data-v-dc692963 data-v-e56f3d57><!--[--><span data-v-e56f3d57>行为面试</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/daily-interview/09-interview-tips/" tabindex="0" data-v-dc692963 data-v-e56f3d57><!--[--><span data-v-e56f3d57>面试技巧</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-6aa21345 data-v-6c893767><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-6c893767 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-6aa21345 data-v-0394ad82 data-v-7bc22406><!--[--><a class="VPSocialLink no-icon" href="https://github.com/datawhalechina/daily-interview" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-bd121fe5><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-6aa21345 data-v-bb2aa2f0 data-v-cf11d7a2><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-cf11d7a2><span class="vpi-more-horizontal icon" data-v-cf11d7a2></span></button><div class="menu" data-v-cf11d7a2><div class="VPMenu" data-v-cf11d7a2 data-v-b98bc113><!----><!--[--><!--[--><!----><div class="group" data-v-bb2aa2f0><div class="item appearance" data-v-bb2aa2f0><p class="label" data-v-bb2aa2f0>Appearance</p><div class="appearance-action" data-v-bb2aa2f0><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-bb2aa2f0 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div></div></div><div class="group" data-v-bb2aa2f0><div class="item social-links" data-v-bb2aa2f0><div class="VPSocialLinks social-links-list" data-v-bb2aa2f0 data-v-7bc22406><!--[--><a class="VPSocialLink no-icon" href="https://github.com/datawhalechina/daily-interview" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-bd121fe5><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-6aa21345 data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div></div><div class="divider" data-v-6aa21345><div class="divider-line" data-v-6aa21345></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-5d98c3a5 data-v-a6f0e41e><div class="container" data-v-a6f0e41e><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-a6f0e41e><span class="vpi-align-left menu-icon" data-v-a6f0e41e></span><span class="menu-text" data-v-a6f0e41e>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-a6f0e41e data-v-8a42e2b4><button data-v-8a42e2b4>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-5d98c3a5 data-v-319d5ca6><div class="curtain" data-v-319d5ca6></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-319d5ca6><span class="visually-hidden" id="sidebar-aria-label" data-v-319d5ca6> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-c40bc020><section class="VPSidebarItem level-0 has-active" data-v-c40bc020 data-v-b3fd67f8><div class="item" role="button" tabindex="0" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><h2 class="text" data-v-b3fd67f8>算法基础</h2><!----></div><div class="items" data-v-b3fd67f8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/daily-interview/01-algorithm-basics/" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>概述</p><!--]--></a><!----></div><!----></div><section class="VPSidebarItem level-1 collapsible" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" role="button" tabindex="0" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><h3 class="text" data-v-b3fd67f8>数据结构</h3><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-b3fd67f8><span class="vpi-chevron-right caret-icon" data-v-b3fd67f8></span></div></div><div class="items" data-v-b3fd67f8><!--[--><div class="VPSidebarItem level-2 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/daily-interview/01-algorithm-basics/data-structures/arrays-and-strings.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>数组与字符串</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/daily-interview/01-algorithm-basics/data-structures/linked-lists.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>链表</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/daily-interview/01-algorithm-basics/data-structures/trees-and-graphs.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>树与图</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/daily-interview/01-algorithm-basics/data-structures/string.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>String</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/daily-interview/01-algorithm-basics/data-structures/graph.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Graph</p><!--]--></a><!----></div><!----></div><!--]--></div></section><section class="VPSidebarItem level-1 collapsible has-active" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" role="button" tabindex="0" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><h3 class="text" data-v-b3fd67f8>算法思想</h3><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-b3fd67f8><span class="vpi-chevron-right caret-icon" data-v-b3fd67f8></span></div></div><div class="items" data-v-b3fd67f8><!--[--><div class="VPSidebarItem level-2 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/daily-interview/01-algorithm-basics/algorithm-concepts/sorting-algorithms.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>排序算法</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/daily-interview/01-algorithm-basics/algorithm-concepts/search-algorithms.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>搜索算法</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/daily-interview/01-algorithm-basics/algorithm-concepts/dynamic-programming.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>动态规划</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/daily-interview/01-algorithm-basics/algorithm-concepts/greedy-algorithms.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>贪心算法</p><!--]--></a><!----></div><!----></div><!--]--></div></section><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-5d98c3a5 data-v-1428d186><div class="VPDoc has-sidebar has-aside" data-v-1428d186 data-v-39a288b8><!--[--><!--]--><div class="container" data-v-39a288b8><div class="aside" data-v-39a288b8><div class="aside-curtain" data-v-39a288b8></div><div class="aside-container" data-v-39a288b8><div class="aside-content" data-v-39a288b8><div class="VPDocAside" data-v-39a288b8 data-v-3f215769><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-3f215769 data-v-a5bbad30><div class="content" data-v-a5bbad30><div class="outline-marker" data-v-a5bbad30></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-a5bbad30>页面导航</div><ul class="VPDocOutlineItem root" data-v-a5bbad30 data-v-b933a997><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-3f215769></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-39a288b8><div class="content-container" data-v-39a288b8><!--[--><!--]--><main class="main" data-v-39a288b8><div style="position:relative;" class="vp-doc _daily-interview_01-algorithm-basics_algorithm-concepts_greedy-algorithms" data-v-39a288b8><div><h1 id="贪心算法" tabindex="-1">贪心算法 <a class="header-anchor" href="#贪心算法" aria-label="Permalink to &quot;贪心算法&quot;">​</a></h1><blockquote><p>是每次只考虑当前最优，目标证明每次是考虑当前最优能够达到局部最优，这就是贪心的思想，一般情况下贪心和排序一起出现，都是先根据条件进行排序，之后基于贪心策略得到最优结果? 面试的时候面试官一般不会出贪心算法，如果可能贪心一般都可以使用动态规划解决，面试官很喜欢出动态规划的题目?</p></blockquote><h2 id="_1-最大连续子序列" tabindex="-1">1. 最大连续子序列 <a class="header-anchor" href="#_1-最大连续子序列" aria-label="Permalink to &quot;1. 最大连续子序列&quot;">​</a></h2><blockquote><p><strong>题目</strong>: 给定一个整数数组，找到一个具有最大和的子数组，返回其最大和?<br><strong>扩展1</strong>: 给定一个整数数组，找出两个 不重?子数组使得它们的和最大?<br><strong>扩展2</strong>: 给定一个整数数组，找出两个不重叠的子数组A和B，使两个子数组和的差的绝对值|SUM(A) - SUM(B)|最大?<br><strong>分析</strong>: 使用这个s表示当前可能满足的最大和，如果s&gt;0,我们认为s对接下来的加操作有帮助，基于s+=nums[i]，if s &lt; 0, 认为s只会对后面造成负影响，两s=nums[i]?<br><strong>扩展问题</strong>: 可以?数组从每个位置k分开，分别结算[1,i]和[i+1, n)的最值，记录的过程中可以使用数组保存下来的已经计算好的值?</p></blockquote><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int maxSubArray(vector&lt;int&gt; &amp;nums) {</span></span>
<span class="line"><span>    int s = 0, ans = -1000000;</span></span>
<span class="line"><span>    for(int i = 0; i &lt; nums.size(); i ++) {</span></span>
<span class="line"><span>        if(s &gt; 0) s += nums[i];</span></span>
<span class="line"><span>        else s = nums[i];</span></span>
<span class="line"><span>        ans = max(s, ans);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return ans;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_2-删除数字" tabindex="-1">2. 删除数字 <a class="header-anchor" href="#_2-删除数字" aria-label="Permalink to &quot;2. 删除数字&quot;">​</a></h2><blockquote><p><strong>题目</strong>: 给定一个以字符串表示的非负整数，从该数字中移除掉k个数位，让剩余数位组成的数字尽可能小，求可能的最小结果?<br><strong>分析</strong>: 从左到右遍历字符串，找到第一个不满足递增的数字删除，一定会保证当前操作之后剩下的数字最小?</p></blockquote><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>string removeKdigits(string &amp;num, int k) {</span></span>
<span class="line"><span>    int i;</span></span>
<span class="line"><span>    while(k --) {</span></span>
<span class="line"><span>        for(i = 0; i &lt; num.size() - 1 &amp;&amp; num[i] &lt;= num[i+1]; i ++);</span></span>
<span class="line"><span>        num.erase(num.begin() + i);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    // remove 0</span></span>
<span class="line"><span>    auto it = num.begin();</span></span>
<span class="line"><span>    while(it != num.end() &amp;&amp; *it == &#39;0&#39;) {</span></span>
<span class="line"><span>        num.erase(it);</span></span>
<span class="line"><span>        it = num.begin();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    if(num.size() == 0) num = &quot;0&quot;;</span></span>
<span class="line"><span>    return num;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h2 id="_3-无重叠区" tabindex="-1">3. 无重叠区? <a class="header-anchor" href="#_3-无重叠区" aria-label="Permalink to &quot;3. 无重叠区?&quot;">​</a></h2><blockquote><p><strong>题目</strong>: 给定一些区间，找到需要移除的最小区间数，以使其余的区间不重叠?<br><strong>分析</strong>: 贪心一般伴随着排序一起出现，我们根据区间的结束使用升序排序，之后进行遍历，如果发现不满足条件，则移除这个不满足的区间?</p></blockquote><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>classs Interval {</span></span>
<span class="line"><span>    int start, end;</span></span>
<span class="line"><span>    Interval(int start, int end) {</span></span>
<span class="line"><span>        this-&gt;start = start;</span></span>
<span class="line"><span>        this-&gt;end = end;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>bool cmp(Interval a, Interval b) {</span></span>
<span class="line"><span>    if(a.end &lt; b.end) return 1;</span></span>
<span class="line"><span>    else return 0;</span></span>
<span class="line"><span>}     </span></span>
<span class="line"><span>int eraseOverlapIntervals(vector&lt;Interval&gt; &amp;intervals) {</span></span>
<span class="line"><span>    sort(intervals.begin(), intervals.end(), cmp);    </span></span>
<span class="line"><span>    int cnt = 0;</span></span>
<span class="line"><span>    Interval tmp = intervals[0];</span></span>
<span class="line"><span>    for(int i = 1; i &lt; intervals.size(); i ++) {</span></span>
<span class="line"><span>        if(tmp.end &lt;= intervals[i].start) tmp = intervals[i];</span></span>
<span class="line"><span>        else {</span></span>
<span class="line"><span>            cnt ++;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return cnt;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h2 id="_4-合并数字" tabindex="-1">4. 合并数字 <a class="header-anchor" href="#_4-合并数字" aria-label="Permalink to &quot;4. 合并数字&quot;">​</a></h2><blockquote><p><strong>题目</strong>: 给出n个数，现在要将这n个数合并成一个数，每次只能选择两个数a,b合并，每次合并需要消耗a+b的能量，输出将这n个数合并成一个数后消耗的最小能量?<br><strong>分析</strong>: 参考哈夫曼树的构造，每一次合并两个最小的数，直到剩下一个数字，因为每次要选择两个最小的，需要用到最小堆来实现，可以使用C++SLT中的优先队列. 根据这个题目，请大家<strong>自行补上哈夫曼树</strong>?</p></blockquote><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int mergeNumber(vector&lt;int&gt; &amp;numbers) {</span></span>
<span class="line"><span>    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;</span></span>
<span class="line"><span>    for(int i = 0; i &lt; numbers.size(); i ++) {</span></span>
<span class="line"><span>        pq.push(numbers[i]);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    int cost = 0;</span></span>
<span class="line"><span>    while(pq.size() &gt; 1) {</span></span>
<span class="line"><span>        int a = pq.top();</span></span>
<span class="line"><span>        pq.pop();</span></span>
<span class="line"><span>        int b = pq.top();</span></span>
<span class="line"><span>        pq.pop();</span></span>
<span class="line"><span>        cost += (a + b);</span></span>
<span class="line"><span>        pq.push(a + b);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return cost;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h2 id="_5-最小支撑树" tabindex="-1">5. 最小支撑树 <a class="header-anchor" href="#_5-最小支撑树" aria-label="Permalink to &quot;5. 最小支撑树&quot;">​</a></h2><blockquote><p>题目: 使用kruskal算法，构造最小支撑树? 分析: 详见百度百科或者wikipedia.<br> 代码: <a href="https://www.geeksforgeeks.org/kruskals-minimum-spanning-tree-algorithm-greedy-algo-2/">kruskal code</a></p></blockquote><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>struct Edge { </span></span>
<span class="line"><span>    int src, dest, weight; </span></span>
<span class="line"><span>}; </span></span>
<span class="line"><span>struct Graph { </span></span>
<span class="line"><span>    int V, E;   </span></span>
<span class="line"><span>    struct Edge* edge; </span></span>
<span class="line"><span>}; </span></span>
<span class="line"><span>struct Graph* createGraph(int V, int E) { </span></span>
<span class="line"><span>    struct Graph* graph = new Graph; </span></span>
<span class="line"><span>    graph-&gt;V = V; </span></span>
<span class="line"><span>    graph-&gt;E = E;   </span></span>
<span class="line"><span>    graph-&gt;edge = new Edge[E]; </span></span>
<span class="line"><span>    return graph; </span></span>
<span class="line"><span>} </span></span>
<span class="line"><span>struct subset { </span></span>
<span class="line"><span>    int parent; </span></span>
<span class="line"><span>    int rank; </span></span>
<span class="line"><span>}; </span></span>
<span class="line"><span>int find(struct subset subsets[], int i) { </span></span>
<span class="line"><span>    if (subsets[i].parent != i) </span></span>
<span class="line"><span>        subsets[i].parent = find(subsets, subsets[i].parent); </span></span>
<span class="line"><span>    return subsets[i].parent; </span></span>
<span class="line"><span>} </span></span>
<span class="line"><span>void Union(struct subset subsets[], int x, int y) { </span></span>
<span class="line"><span>    int xroot = find(subsets, x); </span></span>
<span class="line"><span>    int yroot = find(subsets, y);   </span></span>
<span class="line"><span>    if (subsets[xroot].rank &lt; subsets[yroot].rank) </span></span>
<span class="line"><span>        subsets[xroot].parent = yroot; </span></span>
<span class="line"><span>    else if (subsets[xroot].rank &gt; subsets[yroot].rank) </span></span>
<span class="line"><span>        subsets[yroot].parent = xroot;   </span></span>
<span class="line"><span>    else { </span></span>
<span class="line"><span>        subsets[yroot].parent = xroot; </span></span>
<span class="line"><span>        subsets[xroot].rank++; </span></span>
<span class="line"><span>    } </span></span>
<span class="line"><span>} </span></span>
<span class="line"><span>int myComp(const void* a, const void* b) { </span></span>
<span class="line"><span>    struct Edge* a1 = (struct Edge*)a; </span></span>
<span class="line"><span>    struct Edge* b1 = (struct Edge*)b; </span></span>
<span class="line"><span>    return a1-&gt;weight &gt; b1-&gt;weight; </span></span>
<span class="line"><span>} </span></span>
<span class="line"><span>void KruskalMST(struct Graph* graph) { </span></span>
<span class="line"><span>    int V = graph-&gt;V; </span></span>
<span class="line"><span>    struct Edge result[V];  </span></span>
<span class="line"><span>    int e = 0; </span></span>
<span class="line"><span>    int i = 0; </span></span>
<span class="line"><span>    qsort(graph-&gt;edge, graph-&gt;E, sizeof(graph-&gt;edge[0]), myComp);   </span></span>
<span class="line"><span>    struct subset *subsets = </span></span>
<span class="line"><span>        (struct subset*) malloc( V * sizeof(struct subset) ); </span></span>
<span class="line"><span>    for (int v = 0; v &lt; V; ++v) { </span></span>
<span class="line"><span>        subsets[v].parent = v; </span></span>
<span class="line"><span>        subsets[v].rank = 0; </span></span>
<span class="line"><span>    }   </span></span>
<span class="line"><span>    while (e &lt; V - 1) { </span></span>
<span class="line"><span>        struct Edge next_edge = graph-&gt;edge[i++];   </span></span>
<span class="line"><span>        int x = find(subsets, next_edge.src); </span></span>
<span class="line"><span>        int y = find(subsets, next_edge.dest);   </span></span>
<span class="line"><span>        if (x != y) { </span></span>
<span class="line"><span>            result[e++] = next_edge; </span></span>
<span class="line"><span>            Union(subsets, x, y); </span></span>
<span class="line"><span>        } </span></span>
<span class="line"><span>    }   </span></span>
<span class="line"><span>    return; </span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br></div></div><h2 id="_6-补齐数组" tabindex="-1">6. 补齐数组 <a class="header-anchor" href="#_6-补齐数组" aria-label="Permalink to &quot;6. 补齐数组&quot;">​</a></h2><blockquote><p>题目: 给出一个正整数数组nums和一个整数n，向数组添加patch元素，使得范围[1, n]包含的任何数字都可以由数组中某些元素的总和形成。返回所需的最少补齐数?<br> 分析?</p><ol><li>升序排序?</li><li>使用r表示目前可以表示的右边界，如果当前?&gt; r, 超出范围，又因为 [1, n] 区间内的任何数字都可以用 nums 中某几个数字的和来表示，那么只需要有n/2以及 [1, n/2] 区间内任何数字都可以?nums 中某几个数字的和来表示即可。所有我们将r扩大一倍，继续判断是否满足?</li><li>直到 r &gt;= n?</li></ol></blockquote><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int minPatches(vector&lt;int&gt; &amp;nums, int n) {</span></span>
<span class="line"><span>    sort(nums.begin(), nums.end());</span></span>
<span class="line"><span>    long long r = 1;</span></span>
<span class="line"><span>    int i = 0;</span></span>
<span class="line"><span>    int cnt = 0;</span></span>
<span class="line"><span>    while(r &lt;= n) {</span></span>
<span class="line"><span>        if(i &lt; nums.size() &amp;&amp; nums[i] &lt;= r) r += nums[i++];</span></span>
<span class="line"><span>        else {</span></span>
<span class="line"><span>            cnt ++;</span></span>
<span class="line"><span>            r *= 2;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return cnt;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h2 id="_7-买卖股票的最佳时" tabindex="-1">7. 买卖股票的最佳时? <a class="header-anchor" href="#_7-买卖股票的最佳时" aria-label="Permalink to &quot;7. 买卖股票的最佳时?&quot;">​</a></h2><blockquote><p>题目: 假设有一个数组，它的第i个元素是一支给定的股票在第i天的价格。如果你最多只允许完成一次交?例如,一次买卖股?,设计一个算法来找出最大利润?<br> 分析: 先低价买入，再高价卖出，因此从前向后，记录最小值并且更新最有结果，</p></blockquote><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int maxProfit(vector&lt;int&gt; &amp;prices) {</span></span>
<span class="line"><span>    int minp = prices[0];</span></span>
<span class="line"><span>    int ans = 0;</span></span>
<span class="line"><span>    for(int i = 1; i &lt; prices.size(); i ++) {</span></span>
<span class="line"><span>        ans = max(ans, prices[i] - minp);</span></span>
<span class="line"><span>        minp = min(minp, prices[i]);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return ans;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_8-买卖股票的最佳时机ii" tabindex="-1">8. 买卖股票的最佳时机II <a class="header-anchor" href="#_8-买卖股票的最佳时机ii" aria-label="Permalink to &quot;8. 买卖股票的最佳时机II&quot;">​</a></h2><blockquote><p><strong>题目</strong>: 假设有一个数组，它的第i个元素是一个给定的股票在第i天的价格。设计一个算法来找到最大的利润。你可以完成尽可能多的交?多次买卖股票)。然?你不能同时参与多个交?你必须在再次购买前出售股??<br><strong>分析</strong>: 多次买卖，我们可以尽可能多的买卖股票，如果满足prices[i+1] &gt; price[i]，就进行一次买卖，其实我们知道如果是一个递增序列?prices[i+1] - prices[i]) + (prices[i] - prices[i-1]) = prices[i+1] - prices[i]，可以保证我们将所有可能的买卖识别出来?</p></blockquote><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int maxProfit(vector&lt;int&gt; &amp;prices) {</span></span>
<span class="line"><span>    int sum = 0;</span></span>
<span class="line"><span>    for(int i=1;i&lt;prices.size();i++){</span></span>
<span class="line"><span>        if(prices[i] &gt; prices[i-1]){</span></span>
<span class="line"><span>            sum += prices[i] - prices[i-1];</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return sum;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_9-买卖股票的最佳时机含手续" tabindex="-1">9. 买卖股票的最佳时机含手续? <a class="header-anchor" href="#_9-买卖股票的最佳时机含手续" aria-label="Permalink to &quot;9. 买卖股票的最佳时机含手续?&quot;">​</a></h2><blockquote><p><strong>题目</strong>: 给定一个数组，其中第i个元素是一支股票在第i天的价格，以及一个非负数 fee 代表了交易手续费。（只需要在卖出时支?fee）。你可以进行任意次交易，而每次交易都必须付手续费，而且你不能持有超?支数量的股票（也就是说，你在买入之前需要先把之前买入的卖出）。返回可以获得的最大利润?<br><strong>分析</strong>:</p><ul><li>我们考虑最朴素的方法，对于每一天，如果当前有股票，考虑出售或者保留，如果没股票，考虑购买或者跳过，进行dfs搜索。每天都有两种操作，时间复杂度为O(2^n).</li><li>如何优化呢？我们用动态规划的思想来解决这个问题，考虑每一天同时维护两种状态：拥有股票(own)状态和已经售出股票(sell)状态。用own和sell分别保留这两种状态到目前为止所拥有的最大利润?对于sell，用前一天own状态转移，比较卖出持有股是否能得到更多的利润，即sell = max(sell , own + price - fee)?而对于own , 我们考虑是否买新的股票更能赚?换言之，更优惠），own=max( own, sell-price).</li><li>初始化我们要把sell设为0表示最初是sell状态且没有profit，把own设为负无穷因为最初不存在该状态，我们不希望从这个状态进行转?</li><li>因为我们保存的都是最优状态，所以在买卖股票时候取max能保证最优性不?</li><li>最后直接返回sell即可.</li><li>来自(<a href="https://www.jiuzhang.com/solution/best-time-to-buy-and-sell-stock-with-transaction-fee/#tag-highlight-lang-cpp" target="_blank" rel="noreferrer">https://www.jiuzhang.com/solution/best-time-to-buy-and-sell-stock-with-transaction-fee/#tag-highlight-lang-cpp</a>)</li></ul></blockquote><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int maxProfit(vector&lt;int&gt; &amp;prices, int fee) {</span></span>
<span class="line"><span>    int sell = 0, buy = -prices[0];</span></span>
<span class="line"><span>    for (int price : prices) {</span></span>
<span class="line"><span>        int sellOld = sell;</span></span>
<span class="line"><span>        sell = max(sell, buy + price - fee);</span></span>
<span class="line"><span>        buy = max(buy, sellOld - price);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return sell;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_10-最后的" tabindex="-1">10. 最后的? <a class="header-anchor" href="#_10-最后的" aria-label="Permalink to &quot;10. 最后的?&quot;">​</a></h2><blockquote><p><strong>题目</strong>: 给你一个n只猫，每一个猫都有一个初始化的萌系数，当一只猫的萌系数变成0它就会离开你。现在你实在受不了这n只萌猫，想要只留下一只猫，并且使它的萌系数最低。每一个你可以选择任意一只猫A去消耗另外一只猫B的萌系数，这样的话猫B的萌系数就会减去猫A的萌系数，当猫A的萌系数不变。通过多次回合之后，最后剩下的猫的萌系数最小是多少?<br><strong>分析</strong>: 我们的目的是留下一只猫，使它的萌系数最小，从这个角度出发，我们可以选择最小萌系数的猫，去消耗其他的猫，如果其他的猫萌系数变?，就离开了。例如最小萌系数的猫的系数是a，对于其他的猫，如果b%a == 0，则经过多次消耗之后，b就会离开，如果b%a!=0, 则结果是经过多轮消耗之后变?b%a, a)，直到一方变?，我们可以发现这是一个求最大公约的算式。因此，最后的猫萌系数是gcd(h[0],h[0],...,h[n-1]);</p></blockquote><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int gcd(int a, int b) {</span></span>
<span class="line"><span>    if(a == 0) return b;</span></span>
<span class="line"><span>    return gcd(b % a, a);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>int solve(vector&lt;int&gt; &amp;h) {</span></span>
<span class="line"><span>    if(h.size() == 1) return h[0];</span></span>
<span class="line"><span>    int ans = gcd(h[0], h[1]);</span></span>
<span class="line"><span>    for(int i = 2; i &lt; h.size(); i ++) {</span></span>
<span class="line"><span>        ans = gcd(ans, h[i]);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return ans;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>```cpp</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div></div></div></main><footer class="VPDocFooter" data-v-39a288b8 data-v-e257564d><!--[--><!--]--><div class="edit-info" data-v-e257564d><div class="edit-link" data-v-e257564d><a class="VPLink link vp-external-link-icon no-icon edit-link-button" href="https://github.com/datawhalechina/daily-interview/edit/master/docs/01-algorithm-basics/algorithm-concepts/greedy-algorithms.md" target="_blank" rel="noreferrer" data-v-e257564d><!--[--><span class="vpi-square-pen edit-link-icon" data-v-e257564d></span> 在 GitHub 上编辑此页<!--]--></a></div><!----></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-e257564d><span class="visually-hidden" id="doc-footer-aria-label" data-v-e257564d>Pager</span><div class="pager" data-v-e257564d><a class="VPLink link pager-link prev" href="/daily-interview/01-algorithm-basics/algorithm-concepts/dynamic-programming.html" data-v-e257564d><!--[--><span class="desc" data-v-e257564d>Previous page</span><span class="title" data-v-e257564d>动态规划</span><!--]--></a></div><div class="pager" data-v-e257564d><!----></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"01-algorithm-basics_algorithm-concepts_dynamic-programming.md\":\"BZ_jASsk\",\"01-algorithm-basics_algorithm-concepts_greedy-algorithms.md\":\"bZiiPNdo\",\"01-algorithm-basics_algorithm-concepts_search-algorithms.md\":\"DHIkz9Z0\",\"01-algorithm-basics_algorithm-concepts_sorting-algorithms.md\":\"XsAqWQKL\",\"01-algorithm-basics_data-structures_arrays-and-strings.md\":\"BiAKl8eD\",\"01-algorithm-basics_data-structures_graph.md\":\"BiLfvW-3\",\"01-algorithm-basics_data-structures_linked-lists.md\":\"DAE9tAIh\",\"01-algorithm-basics_data-structures_string.md\":\"e20m6-pb\",\"01-algorithm-basics_data-structures_trees-and-graphs.md\":\"O24Sxr5b\",\"01-algorithm-basics_index.md\":\"CrSxq5lm\",\"02-programming-languages_index.md\":\"B9RwcGFJ\",\"02-programming-languages_java_java-fundamentals.md\":\"DkwStsiW\",\"02-programming-languages_javascript_javascript-fundamentals.md\":\"CF_SnyU5\",\"02-programming-languages_javascript_nodejs.md\":\"gnZwzX8X\",\"03-computer-basics_computer-network_http-protocol.md\":\"B5JVx_mH\",\"03-computer-basics_computer-network_network-protocols.md\":\"BW55pT2c\",\"03-computer-basics_database_sql-fundamentals.md\":\"bXmk5i0A\",\"03-computer-basics_index.md\":\"Chn9mHVs\",\"03-computer-basics_mathematics_discrete-mathematics.md\":\"b217HIjO\",\"03-computer-basics_mathematics_probability-statistics.md\":\"kKp_X1XJ\",\"03-computer-basics_operating-system_processes-and-threads.md\":\"DXQxTQIj\",\"04-ai-algorithms_computer-vision_cv-fundamentals.md\":\"DVNRws31\",\"04-ai-algorithms_computer-vision_object-detection.md\":\"BomgrqZO\",\"04-ai-algorithms_index.md\":\"DvyNCUL_\",\"04-ai-algorithms_llm_llm-interview-questions.md\":\"ANbzCuDw\",\"04-ai-algorithms_machine-learning_ensemble-learning_adaboost.md\":\"D8UQLpTw\",\"04-ai-algorithms_machine-learning_ensemble-learning_catboost.md\":\"4F6YGiL2\",\"04-ai-algorithms_machine-learning_ensemble-learning_ensemblelearning.md\":\"CyFUzpRy\",\"04-ai-algorithms_machine-learning_ensemble-learning_lightgbm.md\":\"Dq_PEqC2\",\"04-ai-algorithms_machine-learning_ensemble-learning_randomforest.md\":\"BeY7wlhJ\",\"04-ai-algorithms_machine-learning_ensemble-learning_treeembedding.md\":\"DznCClUa\",\"04-ai-algorithms_machine-learning_ensemble-learning_xgboost.md\":\"CzXREpkV\",\"04-ai-algorithms_machine-learning_fundamentals_crf.md\":\"B3QyMhQ0\",\"04-ai-algorithms_machine-learning_fundamentals_gradient-descent.md\":\"Bt962jiy\",\"04-ai-algorithms_machine-learning_fundamentals_hmm.md\":\"DSly0YXe\",\"04-ai-algorithms_machine-learning_fundamentals_ml-fundamentals.md\":\"CvKvoVtO\",\"04-ai-algorithms_machine-learning_fundamentals_overfitting-underfitting.md\":\"DSY25CHp\",\"04-ai-algorithms_machine-learning_fundamentals_prophet.md\":\"m-nt9Vw8\",\"04-ai-algorithms_machine-learning_model-evaluation_abtest.md\":\"DpjvaYs_\",\"04-ai-algorithms_machine-learning_model-evaluation_metrics.md\":\"cEVozeXe\",\"04-ai-algorithms_machine-learning_supervised-learning_decisiontree.md\":\"CY0bKxVn\",\"04-ai-algorithms_machine-learning_supervised-learning_knn.md\":\"1iX4y0-G\",\"04-ai-algorithms_machine-learning_supervised-learning_linear-logistic-regression.md\":\"Ddn5i_L0\",\"04-ai-algorithms_machine-learning_supervised-learning_naivebayes.md\":\"ignoVyy7\",\"04-ai-algorithms_machine-learning_supervised-learning_svm.md\":\"Bw1BJygO\",\"04-ai-algorithms_machine-learning_unsupervised-learning_kmeans.md\":\"THwCc0EQ\",\"04-ai-algorithms_nlp_deep-learning-models.md\":\"CqW6Dp5Z\",\"04-ai-algorithms_nlp_text-representation.md\":\"BBBKrbGj\",\"04-ai-algorithms_recommendation_collaborative_filtering.md\":\"DHH_Aa4s\",\"04-ai-algorithms_recommendation_deepfm.md\":\"Bpk6C6KJ\",\"04-ai-algorithms_recommendation_gbdt_lr.md\":\"DKZ6n8K_\",\"05-system-design_index.md\":\"3ZTSl1Hb\",\"06-development-tech_big-data_big-data-interview.md\":\"C4xm9rso\",\"06-development-tech_big-data_hadoop-ecosystem.md\":\"DvHeUeKs\",\"06-development-tech_big-data_index.md\":\"C74taiHu\",\"06-development-tech_big-data_mapreduce.md\":\"Bq5Z56Fi\",\"06-development-tech_frontend_css-advanced.md\":\"0UHwPlN4\",\"06-development-tech_frontend_frontend-frameworks.md\":\"D0P4-vFU\",\"06-development-tech_frontend_html_css.md\":\"Co3mLxtC\",\"06-development-tech_index.md\":\"Bk52STSZ\",\"07-project-experience_index.md\":\"BvXMPmfl\",\"08-behavioral-interview_index.md\":\"CAmH8rIT\",\"09-interview-tips_index.md\":\"XrAh8pnl\",\"09-interview-tips_mock-interview.md\":\"CBgRd55b\",\"index.md\":\"BslIEo9M\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"Daily Interview - 面试必看\",\"description\":\"每一个面试者面试之前必看一遍的小面经\",\"base\":\"/daily-interview/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"首页\",\"link\":\"/\"},{\"text\":\"算法基础\",\"link\":\"/01-algorithm-basics/\"},{\"text\":\"编程语言\",\"link\":\"/02-programming-languages/\"},{\"text\":\"计算机基础\",\"link\":\"/03-computer-basics/\"},{\"text\":\"AI算法\",\"link\":\"/04-ai-algorithms/\"},{\"text\":\"系统设计\",\"link\":\"/05-system-design/\"},{\"text\":\"开发技术\",\"link\":\"/06-development-tech/\"},{\"text\":\"项目经验\",\"link\":\"/07-project-experience/\"},{\"text\":\"行为面试\",\"link\":\"/08-behavioral-interview/\"},{\"text\":\"面试技巧\",\"link\":\"/09-interview-tips/\"}],\"sidebar\":{\"/01-algorithm-basics/\":[{\"text\":\"算法基础\",\"items\":[{\"text\":\"概述\",\"link\":\"/01-algorithm-basics/\"},{\"text\":\"数据结构\",\"collapsed\":false,\"items\":[{\"text\":\"数组与字符串\",\"link\":\"/01-algorithm-basics/data-structures/arrays-and-strings\"},{\"text\":\"链表\",\"link\":\"/01-algorithm-basics/data-structures/linked-lists\"},{\"text\":\"树与图\",\"link\":\"/01-algorithm-basics/data-structures/trees-and-graphs\"},{\"text\":\"String\",\"link\":\"/01-algorithm-basics/data-structures/string\"},{\"text\":\"Graph\",\"link\":\"/01-algorithm-basics/data-structures/graph\"}]},{\"text\":\"算法思想\",\"collapsed\":false,\"items\":[{\"text\":\"排序算法\",\"link\":\"/01-algorithm-basics/algorithm-concepts/sorting-algorithms\"},{\"text\":\"搜索算法\",\"link\":\"/01-algorithm-basics/algorithm-concepts/search-algorithms\"},{\"text\":\"动态规划\",\"link\":\"/01-algorithm-basics/algorithm-concepts/dynamic-programming\"},{\"text\":\"贪心算法\",\"link\":\"/01-algorithm-basics/algorithm-concepts/greedy-algorithms\"}]}]}],\"/02-programming-languages/\":[{\"text\":\"编程语言\",\"items\":[{\"text\":\"概述\",\"link\":\"/02-programming-languages/\"},{\"text\":\"Java\",\"collapsed\":false,\"items\":[{\"text\":\"Java基础\",\"link\":\"/02-programming-languages/Java/java-fundamentals\"}]},{\"text\":\"JavaScript\",\"collapsed\":false,\"items\":[{\"text\":\"JavaScript基础\",\"link\":\"/02-programming-languages/JavaScript/javascript-fundamentals\"},{\"text\":\"NodeJS\",\"link\":\"/02-programming-languages/JavaScript/NodeJS\"}]}]}],\"/03-computer-basics/\":[{\"text\":\"计算机基础\",\"items\":[{\"text\":\"概述\",\"link\":\"/03-computer-basics/\"},{\"text\":\"操作系统\",\"collapsed\":false,\"items\":[{\"text\":\"进程与线程\",\"link\":\"/03-computer-basics/operating-system/processes-and-threads\"}]},{\"text\":\"计算机网络\",\"collapsed\":false,\"items\":[{\"text\":\"网络协议\",\"link\":\"/03-computer-basics/computer-network/network-protocols\"},{\"text\":\"HTTP协议\",\"link\":\"/03-computer-basics/computer-network/http-protocol\"}]},{\"text\":\"数据库\",\"collapsed\":false,\"items\":[{\"text\":\"SQL基础\",\"link\":\"/03-computer-basics/database/sql-fundamentals\"}]},{\"text\":\"数学基础\",\"collapsed\":false,\"items\":[{\"text\":\"概率统计\",\"link\":\"/03-computer-basics/mathematics/probability-statistics\"},{\"text\":\"离散数学\",\"link\":\"/03-computer-basics/mathematics/discrete-mathematics\"}]}]}],\"/04-ai-algorithms/\":[{\"text\":\"AI算法\",\"items\":[{\"text\":\"概述\",\"link\":\"/04-ai-algorithms/\"},{\"text\":\"机器学习\",\"collapsed\":false,\"items\":[{\"text\":\"基础理论\",\"collapsed\":false,\"items\":[{\"text\":\"机器学习基础\",\"link\":\"/04-ai-algorithms/machine-learning/fundamentals/ml-fundamentals\"},{\"text\":\"过拟合与欠拟合\",\"link\":\"/04-ai-algorithms/machine-learning/fundamentals/overfitting-underfitting\"},{\"text\":\"梯度下降\",\"link\":\"/04-ai-algorithms/machine-learning/fundamentals/gradient-descent\"},{\"text\":\"HMM\",\"link\":\"/04-ai-algorithms/machine-learning/fundamentals/HMM\"},{\"text\":\"CRF\",\"link\":\"/04-ai-algorithms/machine-learning/fundamentals/CRF\"},{\"text\":\"Prophet\",\"link\":\"/04-ai-algorithms/machine-learning/fundamentals/Prophet\"}]},{\"text\":\"监督学习\",\"collapsed\":false,\"items\":[{\"text\":\"线性回归+逻辑回归\",\"link\":\"/04-ai-algorithms/machine-learning/supervised-learning/linear-logistic-regression\"},{\"text\":\"决策树\",\"link\":\"/04-ai-algorithms/machine-learning/supervised-learning/DecisionTree\"},{\"text\":\"SVM\",\"link\":\"/04-ai-algorithms/machine-learning/supervised-learning/SVM\"},{\"text\":\"朴素贝叶斯\",\"link\":\"/04-ai-algorithms/machine-learning/supervised-learning/NaiveBayes\"},{\"text\":\"kNN\",\"link\":\"/04-ai-algorithms/machine-learning/supervised-learning/kNN\"}]},{\"text\":\"无监督学习\",\"collapsed\":false,\"items\":[{\"text\":\"K-means\",\"link\":\"/04-ai-algorithms/machine-learning/unsupervised-learning/kmeans\"}]},{\"text\":\"集成学习\",\"collapsed\":false,\"items\":[{\"text\":\"集成学习基础\",\"link\":\"/04-ai-algorithms/machine-learning/ensemble-learning/EnsembleLearning\"},{\"text\":\"随机森林\",\"link\":\"/04-ai-algorithms/machine-learning/ensemble-learning/RandomForest\"},{\"text\":\"AdaBoost\",\"link\":\"/04-ai-algorithms/machine-learning/ensemble-learning/Adaboost\"},{\"text\":\"XGBoost\",\"link\":\"/04-ai-algorithms/machine-learning/ensemble-learning/XGBoost\"},{\"text\":\"LightGBM\",\"link\":\"/04-ai-algorithms/machine-learning/ensemble-learning/LightGBM\"},{\"text\":\"CatBoost\",\"link\":\"/04-ai-algorithms/machine-learning/ensemble-learning/Catboost\"},{\"text\":\"Tree Embedding\",\"link\":\"/04-ai-algorithms/machine-learning/ensemble-learning/TreeEmbedding\"}]},{\"text\":\"模型评估\",\"collapsed\":false,\"items\":[{\"text\":\"评估指标\",\"link\":\"/04-ai-algorithms/machine-learning/model-evaluation/metrics\"},{\"text\":\"A/B测试\",\"link\":\"/04-ai-algorithms/machine-learning/model-evaluation/ABTest\"}]}]},{\"text\":\"计算机视觉\",\"collapsed\":false,\"items\":[{\"text\":\"CV基础\",\"link\":\"/04-ai-algorithms/computer-vision/cv-fundamentals\"},{\"text\":\"目标检测\",\"link\":\"/04-ai-algorithms/computer-vision/object-detection\"}]},{\"text\":\"自然语言处理\",\"collapsed\":false,\"items\":[{\"text\":\"文本表征方式\",\"link\":\"/04-ai-algorithms/nlp/text-representation\"},{\"text\":\"深度学习模型\",\"link\":\"/04-ai-algorithms/nlp/deep-learning-models\"}]},{\"text\":\"推荐系统\",\"collapsed\":false,\"items\":[{\"text\":\"协同过滤\",\"link\":\"/04-ai-algorithms/recommendation/collaborative_filtering\"},{\"text\":\"DeepFM\",\"link\":\"/04-ai-algorithms/recommendation/deepfm\"},{\"text\":\"GBDT+LR\",\"link\":\"/04-ai-algorithms/recommendation/gbdt_lr\"}]},{\"text\":\"大语言模型\",\"collapsed\":false,\"items\":[{\"text\":\"LLM面试题\",\"link\":\"/04-ai-algorithms/llm/llm-interview-questions\"}]}]}],\"/05-system-design/\":[{\"text\":\"系统设计\",\"items\":[{\"text\":\"概述\",\"link\":\"/05-system-design/\"}]}],\"/06-development-tech/\":[{\"text\":\"开发技术\",\"items\":[{\"text\":\"概述\",\"link\":\"/06-development-tech/\"},{\"text\":\"前端开发\",\"collapsed\":false,\"items\":[{\"text\":\"HTML & CSS\",\"link\":\"/06-development-tech/frontend/HTML_CSS\"},{\"text\":\"CSS进阶\",\"link\":\"/06-development-tech/frontend/css-advanced\"},{\"text\":\"前端框架\",\"link\":\"/06-development-tech/frontend/frontend-frameworks\"}]},{\"text\":\"大数据\",\"collapsed\":false,\"items\":[{\"text\":\"Hadoop生态\",\"link\":\"/06-development-tech/big-data/hadoop-ecosystem\"},{\"text\":\"MapReduce\",\"link\":\"/06-development-tech/big-data/mapreduce\"},{\"text\":\"大数据面试题\",\"link\":\"/06-development-tech/big-data/big-data-interview\"},{\"text\":\"大数据概述\",\"link\":\"/06-development-tech/big-data/\"}]}]}],\"/07-project-experience/\":[{\"text\":\"项目经验\",\"items\":[{\"text\":\"概述\",\"link\":\"/07-project-experience/\"}]}],\"/08-behavioral-interview/\":[{\"text\":\"行为面试\",\"items\":[{\"text\":\"概述\",\"link\":\"/08-behavioral-interview/\"}]}],\"/09-interview-tips/\":[{\"text\":\"面试技巧\",\"items\":[{\"text\":\"概述\",\"link\":\"/09-interview-tips/\"},{\"text\":\"模拟面试\",\"link\":\"/09-interview-tips/mock-interview\"}]}]},\"search\":{\"provider\":\"local\"},\"editLink\":{\"pattern\":\"https://github.com/datawhalechina/daily-interview/edit/master/docs/:path\",\"text\":\"在 GitHub 上编辑此页\"},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/datawhalechina/daily-interview\"}],\"outline\":{\"level\":[2,3],\"label\":\"页面导航\"}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>