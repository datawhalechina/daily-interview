<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>动态规划(DP) | Daily Interview - 面试必看</title>
    <meta name="description" content="每一个面试者面试之前必看一遍的小面经">
    <meta name="generator" content="VitePress v1.6.4">
    <link rel="preload stylesheet" href="/daily-interview/assets/style.CZXOQdG2.css" as="style">
    <link rel="preload stylesheet" href="/daily-interview/vp-icons.css" as="style">
    
    <script type="module" src="/daily-interview/assets/app.B7Dcrs0-.js"></script>
    <link rel="preload" href="/daily-interview/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/daily-interview/assets/chunks/theme.CITFd1rp.js">
    <link rel="modulepreload" href="/daily-interview/assets/chunks/framework.DT5BmYxR.js">
    <link rel="modulepreload" href="/daily-interview/assets/01-algorithm-basics_algorithm-concepts_dynamic-programming.md.DxbDkdYX.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-5d98c3a5><!--[--><!--]--><!--[--><span tabindex="-1" data-v-0b0ada53></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-0b0ada53>Skip to content</a><!--]--><!----><header class="VPNav" data-v-5d98c3a5 data-v-ae24b3ad><div class="VPNavBar" data-v-ae24b3ad data-v-6aa21345><div class="wrapper" data-v-6aa21345><div class="container" data-v-6aa21345><div class="title" data-v-6aa21345><div class="VPNavBarTitle has-sidebar" data-v-6aa21345 data-v-1168a8e4><a class="title" href="/daily-interview/" data-v-1168a8e4><!--[--><!--]--><!----><span data-v-1168a8e4>Daily Interview - 面试必看</span><!--[--><!--]--></a></div></div><div class="content" data-v-6aa21345><div class="content-body" data-v-6aa21345><!--[--><!--]--><div class="VPNavBarSearch search" data-v-6aa21345><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-6aa21345 data-v-dc692963><span id="main-nav-aria-label" class="visually-hidden" data-v-dc692963> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/daily-interview/" tabindex="0" data-v-dc692963 data-v-e56f3d57><!--[--><span data-v-e56f3d57>首页</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/daily-interview/01-algorithm-basics/" tabindex="0" data-v-dc692963 data-v-e56f3d57><!--[--><span data-v-e56f3d57>算法基础</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/daily-interview/02-programming-languages/" tabindex="0" data-v-dc692963 data-v-e56f3d57><!--[--><span data-v-e56f3d57>编程语言</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/daily-interview/03-computer-basics/" tabindex="0" data-v-dc692963 data-v-e56f3d57><!--[--><span data-v-e56f3d57>计算机基础</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/daily-interview/04-ai-algorithms/" tabindex="0" data-v-dc692963 data-v-e56f3d57><!--[--><span data-v-e56f3d57>AI算法</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/daily-interview/05-system-design/" tabindex="0" data-v-dc692963 data-v-e56f3d57><!--[--><span data-v-e56f3d57>系统设计</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/daily-interview/06-development-tech/" tabindex="0" data-v-dc692963 data-v-e56f3d57><!--[--><span data-v-e56f3d57>开发技术</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/daily-interview/07-project-experience/" tabindex="0" data-v-dc692963 data-v-e56f3d57><!--[--><span data-v-e56f3d57>项目经验</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/daily-interview/08-behavioral-interview/" tabindex="0" data-v-dc692963 data-v-e56f3d57><!--[--><span data-v-e56f3d57>行为面试</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/daily-interview/09-interview-tips/" tabindex="0" data-v-dc692963 data-v-e56f3d57><!--[--><span data-v-e56f3d57>面试技巧</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-6aa21345 data-v-6c893767><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-6c893767 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-6aa21345 data-v-0394ad82 data-v-7bc22406><!--[--><a class="VPSocialLink no-icon" href="https://github.com/datawhalechina/daily-interview" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-bd121fe5><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-6aa21345 data-v-bb2aa2f0 data-v-cf11d7a2><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-cf11d7a2><span class="vpi-more-horizontal icon" data-v-cf11d7a2></span></button><div class="menu" data-v-cf11d7a2><div class="VPMenu" data-v-cf11d7a2 data-v-b98bc113><!----><!--[--><!--[--><!----><div class="group" data-v-bb2aa2f0><div class="item appearance" data-v-bb2aa2f0><p class="label" data-v-bb2aa2f0>Appearance</p><div class="appearance-action" data-v-bb2aa2f0><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-bb2aa2f0 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div></div></div><div class="group" data-v-bb2aa2f0><div class="item social-links" data-v-bb2aa2f0><div class="VPSocialLinks social-links-list" data-v-bb2aa2f0 data-v-7bc22406><!--[--><a class="VPSocialLink no-icon" href="https://github.com/datawhalechina/daily-interview" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-bd121fe5><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-6aa21345 data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div></div><div class="divider" data-v-6aa21345><div class="divider-line" data-v-6aa21345></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-5d98c3a5 data-v-a6f0e41e><div class="container" data-v-a6f0e41e><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-a6f0e41e><span class="vpi-align-left menu-icon" data-v-a6f0e41e></span><span class="menu-text" data-v-a6f0e41e>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-a6f0e41e data-v-8a42e2b4><button data-v-8a42e2b4>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-5d98c3a5 data-v-319d5ca6><div class="curtain" data-v-319d5ca6></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-319d5ca6><span class="visually-hidden" id="sidebar-aria-label" data-v-319d5ca6> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-c40bc020><section class="VPSidebarItem level-0 has-active" data-v-c40bc020 data-v-b3fd67f8><div class="item" role="button" tabindex="0" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><h2 class="text" data-v-b3fd67f8>算法基础</h2><!----></div><div class="items" data-v-b3fd67f8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/daily-interview/01-algorithm-basics/" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>概述</p><!--]--></a><!----></div><!----></div><section class="VPSidebarItem level-1 collapsible" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" role="button" tabindex="0" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><h3 class="text" data-v-b3fd67f8>数据结构</h3><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-b3fd67f8><span class="vpi-chevron-right caret-icon" data-v-b3fd67f8></span></div></div><div class="items" data-v-b3fd67f8><!--[--><div class="VPSidebarItem level-2 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/daily-interview/01-algorithm-basics/data-structures/arrays-and-strings.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>数组与字符串</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/daily-interview/01-algorithm-basics/data-structures/linked-lists.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>链表</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/daily-interview/01-algorithm-basics/data-structures/trees-and-graphs.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>树与图</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/daily-interview/01-algorithm-basics/data-structures/string.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>String</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/daily-interview/01-algorithm-basics/data-structures/graph.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Graph</p><!--]--></a><!----></div><!----></div><!--]--></div></section><section class="VPSidebarItem level-1 collapsible has-active" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" role="button" tabindex="0" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><h3 class="text" data-v-b3fd67f8>算法思想</h3><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-b3fd67f8><span class="vpi-chevron-right caret-icon" data-v-b3fd67f8></span></div></div><div class="items" data-v-b3fd67f8><!--[--><div class="VPSidebarItem level-2 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/daily-interview/01-algorithm-basics/algorithm-concepts/sorting-algorithms.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>排序算法</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/daily-interview/01-algorithm-basics/algorithm-concepts/search-algorithms.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>搜索算法</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/daily-interview/01-algorithm-basics/algorithm-concepts/dynamic-programming.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>动态规划</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/daily-interview/01-algorithm-basics/algorithm-concepts/greedy-algorithms.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>贪心算法</p><!--]--></a><!----></div><!----></div><!--]--></div></section><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-5d98c3a5 data-v-1428d186><div class="VPDoc has-sidebar has-aside" data-v-1428d186 data-v-39a288b8><!--[--><!--]--><div class="container" data-v-39a288b8><div class="aside" data-v-39a288b8><div class="aside-curtain" data-v-39a288b8></div><div class="aside-container" data-v-39a288b8><div class="aside-content" data-v-39a288b8><div class="VPDocAside" data-v-39a288b8 data-v-3f215769><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-3f215769 data-v-a5bbad30><div class="content" data-v-a5bbad30><div class="outline-marker" data-v-a5bbad30></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-a5bbad30>页面导航</div><ul class="VPDocOutlineItem root" data-v-a5bbad30 data-v-b933a997><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-3f215769></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-39a288b8><div class="content-container" data-v-39a288b8><!--[--><!--]--><main class="main" data-v-39a288b8><div style="position:relative;" class="vp-doc _daily-interview_01-algorithm-basics_algorithm-concepts_dynamic-programming" data-v-39a288b8><div><h1 id="动态规划-dp" tabindex="-1">动态规划(DP) <a class="header-anchor" href="#动态规划-dp" aria-label="Permalink to &quot;动态规划(DP)&quot;">​</a></h1><p>动态规划是面试中最常被问道的题目,但是一般情况下的都是常见的一些题目.</p><ol><li><a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408?fr=aladdin" target="_blank" rel="noreferrer">百度百科</a></li><li><a href="https://en.wikipedia.org/wiki/Dynamic_programming" target="_blank" rel="noreferrer">wikipedia</a></li></ol><h2 id="_1-最长上升子序列" tabindex="-1">1. 最长上升子序列 <a class="header-anchor" href="#_1-最长上升子序列" aria-label="Permalink to &quot;1. 最长上升子序列&quot;">​</a></h2><blockquote><p><strong>题目</strong>: 最长上升子序列问题是在一个无序的给定序列中找到一个尽可能长的由低到高排列的子序列，这种子序列不一定是连续的或者唯一的.</p></blockquote><blockquote><p><strong>解析</strong>:</p></blockquote><pre><code>dp[j]: 表示以j结尾的最长子序列的长度,
dp[j] = max(dp[j], dp[i]+1) if(a[i]&lt;d[j]) {i in [1,j]}

return max(dp[1-n])
</code></pre><p>使用二分查找可以得到O(nlog)的算法,这里就不给出,思路也很简单,读者自行查询.</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int lis(vector&lt;int&gt; &amp;nums) {</span></span>
<span class="line"><span>    if(nums.size() == 0) return 0;</span></span>
<span class="line"><span>    memset(dp,0,sizeof(dp));</span></span>
<span class="line"><span>    int ans = 1;</span></span>
<span class="line"><span>    dp[0] = 1;</span></span>
<span class="line"><span>    for(int i=0;i&lt;nums.size();i++){</span></span>
<span class="line"><span>        dp[i] = 1;</span></span>
<span class="line"><span>        for(int j=0;j&lt;i;j++){</span></span>
<span class="line"><span>            if(nums[j] &lt; nums[i]){</span></span>
<span class="line"><span>                dp[i] = max(dp[i],dp[j]+1);</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        ans = max(ans,dp[i]);       </span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return ans;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h2 id="_2-最长公共子序列" tabindex="-1">2. 最长公共子序列 <a class="header-anchor" href="#_2-最长公共子序列" aria-label="Permalink to &quot;2. 最长公共子序列&quot;">​</a></h2><blockquote><p><strong>题目</strong>: 给出两个字符串，找到最长公共子序列(LCS)，返回LCS的长度。</p></blockquote><blockquote><p><strong>解析</strong>:</p></blockquote><pre><code>dp[i][j]: 表示以i和j结尾的最长序列的长度. 
dp[i][j] = max(dp[i-1][j], dp[i][j-1]) if(a[i] != b[j])
dp[i][j] = dp[i-1][j-1] + 1 if(a[i]==b[j])
</code></pre><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int lcs(string &amp;A, string &amp;B) {</span></span>
<span class="line"><span>        int dp[A.size()+1][B.size()+1] = {0};   </span></span>
<span class="line"><span>        for(int i=1;i&lt;=A.size();i++){</span></span>
<span class="line"><span>            for(int j=1;j&lt;=B.size();j++){</span></span>
<span class="line"><span>                dp[i][j] = max(dp[i-1][j],dp[i][j-1]);</span></span>
<span class="line"><span>                if(A[i-1] == B[j-1]){</span></span>
<span class="line"><span>                    dp[i][j] = max(dp[i][j],dp[i-1][j-1]+1);</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        return dp[A.size()][B.size()];</span></span>
<span class="line"><span>    }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h2 id="_3-最长整除子集" tabindex="-1">3. 最长整除子集 <a class="header-anchor" href="#_3-最长整除子集" aria-label="Permalink to &quot;3. 最长整除子集&quot;">​</a></h2><blockquote><p><strong>题目</strong>: 给定一个n个正整数的数组, 找出最长的子序列,使得序列中每一个较小的数都能整除较大的数.</p></blockquote><blockquote><p>Example:</p></blockquote><pre><code>Input : arr[] = {10, 5, 3, 15, 20} 
Output : 3 
最长子序列: 10, 5, 20.
因为: 20能被整除10, 10能被5整除.
</code></pre><blockquote><p><strong>解析</strong>: 这个可以参考最长上升子序列, 首先排序数组.</p></blockquote><pre><code>dp[i]: 表示下标i结尾的,最长的子序列长度
if(a[j] % a[i] == 0) dp[j] = max(dp[j], dp[i]+1) j in [i+1, n]
</code></pre><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int largeSubset(int a[], int n) {</span></span>
<span class="line"><span>    sort(a, a+n);</span></span>
<span class="line"><span>    int dp[n] = {0};</span></span>
<span class="line"><span>    dp[0] = 1;</span></span>
<span class="line"><span>    for(int j = 1; j &lt; n; j++) {</span></span>
<span class="line"><span>        for(int i = 0; i &lt; j; i++) {</span></span>
<span class="line"><span>            if(a[j] % a[i] == 0) {</span></span>
<span class="line"><span>                dp[j] = max(dp[j], dp[i]+1);</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return *max_element(dp, dp+n);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h2 id="_4-背包问题" tabindex="-1">4. 背包问题 <a class="header-anchor" href="#_4-背包问题" aria-label="Permalink to &quot;4. 背包问题&quot;">​</a></h2><blockquote><p><strong>题目</strong>: 在n个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为m，每个物品的大小为A[i].</p></blockquote><blockquote><p><strong>解析</strong>:</p></blockquote><pre><code>表示dp[m]能否装满, dp[m] = dp[m] | dp[m-A[i]])
</code></pre><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int backPack(int m, vector&lt;int&gt; A) {</span></span>
<span class="line"><span>    int dp[m+1];</span></span>
<span class="line"><span>    memset(dp,0,sizeof(dp));</span></span>
<span class="line"><span>    dp[0]=1;</span></span>
<span class="line"><span>    //背包问题的循环顺序很重要</span></span>
<span class="line"><span>    for(int i=0;i&lt;A.size();i++){</span></span>
<span class="line"><span>        for(int j=m;j&gt;=A[i];j--){</span></span>
<span class="line"><span>            dp[j] |= dp[j-A[i]];//注意一下这个语句，类似于，</span></span>
<span class="line"><span>            //if(dp[j-A[i]]==1) dp[j]=1;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    int ans;</span></span>
<span class="line"><span>    for(ans=m;!dp[ans];--ans);   </span></span>
<span class="line"><span>    return ans;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h2 id="_5-编辑距离" tabindex="-1">5. 编辑距离 <a class="header-anchor" href="#_5-编辑距离" aria-label="Permalink to &quot;5. 编辑距离&quot;">​</a></h2><blockquote><p><strong>题目</strong>: 给出两个单词word1和word2，计算出将word1 转换为word2的最少操作次数。 你总共三种操作方法：</p></blockquote><pre><code>插入一个字符
删除一个字符
替换一个字符
</code></pre><blockquote><p><strong>解析</strong>:</p></blockquote><pre><code> 分别表示插入,删除,修改
 dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])+1; // a[i-1] != b[j-1]
dp[i][j] = dp[i-1][j-1] // a[i-1] == b[j-1]
</code></pre><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int minDistance(string &amp;word1, string &amp;word2) {</span></span>
<span class="line"><span>    int dp[word1.size()+1][word2.size()+1];</span></span>
<span class="line"><span>    dp[0][0] = 0;</span></span>
<span class="line"><span>    for(int i=1;i&lt;=word1.size();i++) dp[i][0] = i;</span></span>
<span class="line"><span>    for(int i=1;i&lt;=word2.size();i++) dp[0][i] = i;    </span></span>
<span class="line"><span>    for(int i=1;i&lt;=word1.size();i++){</span></span>
<span class="line"><span>        for(int j=1;j&lt;=word2.size();j++){</span></span>
<span class="line"><span>            if(word1[i-1] == word2[j-1]){</span></span>
<span class="line"><span>                dp[i][j] = dp[i-1][j-1];</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>            else{</span></span>
<span class="line"><span>                dp[i][j] = min(min(dp[i-1][j],dp[i][j-1]),dp[i-1][j-1]) + 1;</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return dp[word1.size()][word2.size()];</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h2 id="_6-矩阵链乘" tabindex="-1">6. 矩阵链乘 <a class="header-anchor" href="#_6-矩阵链乘" aria-label="Permalink to &quot;6. 矩阵链乘&quot;">​</a></h2><blockquote><p><strong>题目</strong>: 给你一个矩阵序列, 找到有效的方式把这些数相乘到一起. Example:</p></blockquote><pre><code>Input: p[] = {40, 20, 30, 10, 30}   
Output: 26000  

表示四个矩阵,分别是A:40x20, B:20x30, C;30x10, D:10x30.
最优的方式是: (A(BC))D --&gt; 
20*30*10 + 40*20*10 + 40*10*30 
</code></pre><blockquote><p><strong>解析</strong>:</p></blockquote><pre><code>dp[i][j]: 表示[i,j]区间上最小值.
dp[i][j] = min(dp[i][j], dp[i][k]+dp[k+1][j]+p[i-1]*p[k]*p[l]) k in [i,j-1]
</code></pre><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int MatrixChainOrder(int p[], int n) {    </span></span>
<span class="line"><span>    int dp[n][n]; </span></span>
<span class="line"><span>    int i, j, k, L, q;   </span></span>
<span class="line"><span>    for (i=1; i&lt;n; i++) { </span></span>
<span class="line"><span>        dp[i][i] = 0; </span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    // L is chain length. </span></span>
<span class="line"><span>    for (L=2; L&lt;n; L++) { </span></span>
<span class="line"><span>        for (i=1; i&lt;n-L+1; i++) { </span></span>
<span class="line"><span>            j = i+L-1; </span></span>
<span class="line"><span>            dp[i][j] = INT_MAX; </span></span>
<span class="line"><span>            for (k=i; k&lt;=j-1; k++) { </span></span>
<span class="line"><span>                q = dp[i][k] + dp[k+1][j] + p[i-1]*p[k]*p[j]; </span></span>
<span class="line"><span>                if (q &lt; dp[i][j]) dp[i][j] = q; </span></span>
<span class="line"><span>            } </span></span>
<span class="line"><span>        } </span></span>
<span class="line"><span>    } </span></span>
<span class="line"><span>    return m[1][n-1]; </span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h2 id="_7-回文划分" tabindex="-1">7. 回文划分 <a class="header-anchor" href="#_7-回文划分" aria-label="Permalink to &quot;7. 回文划分&quot;">​</a></h2><blockquote><p><strong>题目</strong>:给定字符串 s, 需要将它分割成一些子串, 使得每个子串都是回文串. 最少需要分割几次?</p></blockquote><blockquote><p><strong>Example</strong>:</p></blockquote><pre><code>样例 1:
输入: &quot;a&quot;
输出: 0
解释: &quot;a&quot; 本身就是回文串, 无需分割

样例 2:
输入: &quot;aab&quot;
输出: 1
解释: 将 &quot;aab&quot; 分割一次, 得到 &quot;aa&quot; 和 &quot;b&quot;, 它们都是回文串.
</code></pre><blockquote><p><strong>解析</strong>:</p></blockquote><p>可以看作序列型动态规划问题, 设定 dp[i] 表示原串的前 i 个字符最少分割多少次可以使得到的都是回文子串.</p><p>如果 s 前 i 个字符组成的子串本身就是回文串, 则 dp[i] = 0, 否则:</p><pre><code>dp[i] = min{dp[j] + 1} (j &lt; i 并且 s[j + 1], s[j + 2], ... , s[i] 是回文串)
</code></pre><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int minCut(string s) {</span></span>
<span class="line"><span>    int n = s.length();</span></span>
<span class="line"><span>    int f[n + 1];</span></span>
<span class="line"><span>    vector&lt;vector&lt;bool&gt;&gt; isPalin(n, vector&lt;bool&gt;(n, false));</span></span>
<span class="line"><span>    for (int i = 0; i &lt; n; i++) {</span></span>
<span class="line"><span>        isPalin[i][i] = true;</span></span>
<span class="line"><span>        if (i + 1 &lt; n) {</span></span>
<span class="line"><span>            isPalin[i][i + 1] = (s[i] == s[i + 1]);</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    for (int i = n - 1; i &gt;= 0; i--) {</span></span>
<span class="line"><span>        for (int j = i + 2; j &lt; n; j++) {</span></span>
<span class="line"><span>            isPalin[i][j] = isPalin[i + 1][j - 1] &amp;&amp; (s[i] == s[j]);</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    f[0] = -1;</span></span>
<span class="line"><span>    for (int i = 1; i &lt;= n; i++) {</span></span>
<span class="line"><span>        f[i] = i - 1;</span></span>
<span class="line"><span>        for (int j = 0; j &lt; i; j++) {</span></span>
<span class="line"><span>            if (isPalin[j][i - 1]) {</span></span>
<span class="line"><span>                f[i] = min(f[i], f[j] + 1);</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return f[n];</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><h2 id="_8-丑数" tabindex="-1">8. 丑数 <a class="header-anchor" href="#_8-丑数" aria-label="Permalink to &quot;8. 丑数&quot;">​</a></h2><blockquote><p><strong>题目</strong>:设计一个算法，找出只含素因子2，3，5 的第 n 小的数。</p></blockquote><blockquote><p><strong>解析</strong>: 使用2,3,5进行组合,得到第n个丑数.</p></blockquote><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int dp[100000];    </span></span>
<span class="line"><span>int MIN(int x,int y,int z){</span></span>
<span class="line"><span>    return min(min(x,y),z);</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>int nthUglyNumber(int n) {</span></span>
<span class="line"><span>    dp[1] = 1;</span></span>
<span class="line"><span>    int i2,i3,i5; // 分别表示2,3,5的对应的数，目标是使用前面的数字构造后面的数字，</span></span>
<span class="line"><span>    // 不能使用2,3,5的倍数进行构造，否则会出现错误   </span></span>
<span class="line"><span>    i2 = i3 = i5 = 1;</span></span>
<span class="line"><span>    int i=2;</span></span>
<span class="line"><span>    while(i&lt;=n){</span></span>
<span class="line"><span>        int m2 = dp[i2] * 2;</span></span>
<span class="line"><span>        int m3 = dp[i3] * 3;</span></span>
<span class="line"><span>        int m5 = dp[i5] * 5;</span></span>
<span class="line"><span>        int minv = MIN(m2,m3,m5);</span></span>
<span class="line"><span>        dp[i++] = minv;        </span></span>
<span class="line"><span>        if(minv == m2) i2++;</span></span>
<span class="line"><span>        if(minv == m3) i3++;</span></span>
<span class="line"><span>        if(minv == m5) i5++;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return dp[n];</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h2 id="_9-最小花费路径" tabindex="-1">9. 最小花费路径 <a class="header-anchor" href="#_9-最小花费路径" aria-label="Permalink to &quot;9. 最小花费路径&quot;">​</a></h2><blockquote><p><strong>题目</strong>: 给定一个矩阵,求出从左上角到右下角的最小路径的和.</p></blockquote><blockquote><p><strong>解析</strong>:</p></blockquote><pre><code>dp[i][j]: (0,0)到(i,j)的最小路径的和.
dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+a[i][j]
</code></pre><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int minCost(vector&lt;vector&lt;int&gt;&gt; cost){ </span></span>
<span class="line"><span>     int i, j, m, n; </span></span>
<span class="line"><span>     int m = cost.size();</span></span>
<span class="line"><span>     int n = cost[0].size();</span></span>
<span class="line"><span>     int dp[m+1][n+1];   </span></span>
<span class="line"><span>     dp[0][0] = cost[0][0];   </span></span>
<span class="line"><span>     for (i = 1; i &lt;= m; i++) { </span></span>
<span class="line"><span>        dp[i][0] = dp[i-1][0] + cost[i][0];</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    for (j = 1; j &lt;= n; j++) {</span></span>
<span class="line"><span>        dp[0][j] = dp[0][j-1] + cost[0][j]; </span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    for (i = 1; i &lt;= m; i++) {</span></span>
<span class="line"><span>        for (j = 1; j &lt;= n; j++) { </span></span>
<span class="line"><span>            dp[i][j] = min(dp[i-1][j-1],  </span></span>
<span class="line"><span>                        dp[i-1][j],  </span></span>
<span class="line"><span>                        dp[i][j-1]) + cost[i][j]; </span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return dp[m][n]; </span></span>
<span class="line"><span>} </span></span>
<span class="line"><span>int min(int x, int y, int z) { </span></span>
<span class="line"><span>   if (x &lt; y) </span></span>
<span class="line"><span>      return (x &lt; z)? x : z; </span></span>
<span class="line"><span>   else</span></span>
<span class="line"><span>      return (y &lt; z)? y : z; </span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><h2 id="_10-最大矩阵和" tabindex="-1">10. 最大矩阵和 <a class="header-anchor" href="#_10-最大矩阵和" aria-label="Permalink to &quot;10. 最大矩阵和&quot;">​</a></h2><blockquote><p><strong>题目</strong>: 给定一个由整数组成二维矩阵（r*c），现在需要找出它的一个子矩阵，使得这个子矩阵内的所有元素之和最大，并把这个子矩阵称为最大子矩阵。</p></blockquote><blockquote><p>Example:</p></blockquote><pre><code>例子：
0 -2 -7 0 
9 2 -6 2 
-4 1 -4 1 
-1 8 0 -2 
其最大子矩阵为：
9 2 
-4 1 
-1 8 
其元素总和为15。
</code></pre><blockquote><p><strong>解析</strong>: 将矩阵进行求和压缩到一维形式,之后使用一维数组的最大子段和进行计算.</p></blockquote><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int a[101][101],s[101],ma[101];</span></span>
<span class="line"><span>int maxSum(int s[],int ma[],int m){//最大子序列的和</span></span>
<span class="line"><span>    ma[0]=s[0];</span></span>
<span class="line"><span>    for(int i=1;i&lt;m;i++){</span></span>
<span class="line"><span>       if(ma[i-1]&gt;=0) ma[i]=ma[i-1]+s[i];</span></span>
<span class="line"><span>       else ma[i]=s[i];</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    int sum=ma[0];</span></span>
<span class="line"><span>    for(int i=1;i&lt;m;i++){</span></span>
<span class="line"><span>        if(sum&lt;ma[i]) sum=ma[i];</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return sum;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>int maxMatrixSum(int n, int m) {</span></span>
<span class="line"><span>    int res=INT_MIN;//注意序列的最小值</span></span>
<span class="line"><span>    for(int i=0;i&lt;n;i++){</span></span>
<span class="line"><span>        memset(s,0,sizeof(s));</span></span>
<span class="line"><span>        for(int j=i;j&lt;n;j++){</span></span>
<span class="line"><span>            int sum=0;</span></span>
<span class="line"><span>            for(int k=0;k&lt;m;k++){</span></span>
<span class="line"><span>                s[k]+=a[j][k];//转化为一维数组</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>            sum=maxSum(s,ma,m);</span></span>
<span class="line"><span>            if(sum&gt;res) res=sum;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return res;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><h2 id="_11-最大正方形面积" tabindex="-1">11. 最大正方形面积 <a class="header-anchor" href="#_11-最大正方形面积" aria-label="Permalink to &quot;11. 最大正方形面积&quot;">​</a></h2><blockquote><p><strong>题目</strong>: 给你一个二维矩阵，权值为False和True，找到一个最大的正方形，使得里面的值全部为True，输出它的面积.</p></blockquote><blockquote><p>Example:</p></blockquote><pre><code>输入:
[
[1, 1, 0, 0, 1],
[0, 1, 0, 0, 1],
[0, 0, 1, 1, 1],
[0, 0, 1, 1, 1],
[0, 0, 0, 0, 1]
]
输出: 4
</code></pre><blockquote><p><strong>解析</strong>:</p></blockquote><pre><code>构造辅助数组,dp[m][n], 

用m[i][j]表示右下角的1.
if m[i][j]=1 then
    dp[i][j]=min(dp[i][j-],dp[i-1][j], dp[i-1][j-1]) + 1
else:
    dp[i][j] = 0
</code></pre><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int MaxSubSquare(vector&lt;vector&lt;bool&gt;&gt; &amp;matrix) {</span></span>
<span class="line"><span>    int R=matrix.size(), C=matrix[0].size();</span></span>
<span class="line"><span>    vector&lt;vector&lt;int&gt;&gt; dp(matrix.size(), vector&lt;int&gt;(matrix[0].size(), 0));</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    int i, j;           </span></span>
<span class="line"><span>    for(i = 0; i &lt; R; i++) { </span></span>
<span class="line"><span>        dp[i][0] = matrix[i][0];  </span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    for(j = 0; j &lt; C; j++) { </span></span>
<span class="line"><span>        dp[0][j] = matrix[0][j];  </span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    int res = 0;  </span></span>
<span class="line"><span>    for(i = 1; i &lt; R; i++) {  </span></span>
<span class="line"><span>        for(j = 1; j &lt; C; j++) {  </span></span>
<span class="line"><span>            if(matrix[i][j] == 1)  </span></span>
<span class="line"><span>                dp[i][j] = min(dp[i][j-1],min(dp[i-1][j],dp[i-1][j-1])) + 1;  </span></span>
<span class="line"><span>            else</span></span>
<span class="line"><span>                dp[i][j] = 0;  </span></span>
<span class="line"><span>            res = max(res, dp[i][j]);</span></span>
<span class="line"><span>        }  </span></span>
<span class="line"><span>    }  </span></span>
<span class="line"><span>    return res;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h2 id="_12-二进制串个数" tabindex="-1">12. 二进制串个数 <a class="header-anchor" href="#_12-二进制串个数" aria-label="Permalink to &quot;12. 二进制串个数&quot;">​</a></h2><blockquote><p><strong>题目</strong>: 求长度为n的01组成的二进制串中,没有连续1的串的个数.</p></blockquote><blockquote><p><strong>解析</strong>: 分别用a[i]和b[i],表示长度为i,分别0结尾和1结尾的串的个数. 那么</p></blockquote><pre><code>a[i+1] = a[i] + b[i] // 在后面加0
b[i+1] = a[i] // 只能在结尾是0的后面加1
</code></pre><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int countStrings(int n) { </span></span>
<span class="line"><span>    int a[n], b[n]; </span></span>
<span class="line"><span>    a[0] = b[0] = 1; </span></span>
<span class="line"><span>    for (int i = 1; i &lt; n; i++) { </span></span>
<span class="line"><span>        a[i] = a[i-1] + b[i-1]; </span></span>
<span class="line"><span>        b[i] = a[i-1]; </span></span>
<span class="line"><span>    } </span></span>
<span class="line"><span>    return a[n-1] + b[n-1]; </span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_13-交叉字符串" tabindex="-1">13. 交叉字符串 <a class="header-anchor" href="#_13-交叉字符串" aria-label="Permalink to &quot;13. 交叉字符串&quot;">​</a></h2><blockquote><p><strong>题目</strong>: 给出三个字符串:s1、s2、s3，判断s3是否由s1和s2交叉构成。<br><strong>解析</strong>:</p></blockquote><pre><code>dp[i][j]: s1[1,i] 和 s2[1,j] 是否能够组成s3[i+j]

dp[i][j] = dp[i][j] || dp[i-1][j]  if s1[i] == s3[i+j-1]

dp[i][j] = dp[i][j] || dp[i][j-1]  if s2[j] == s3[i+j-1]
</code></pre><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>bool isInterleave(string &amp;s1, string &amp;s2, string &amp;s3) {</span></span>
<span class="line"><span>    if(s1.size() + s2.size() != s3.size()) return false;</span></span>
<span class="line"><span>    int dp[s1.size() + 1][s2.size() + 1] = {0};</span></span>
<span class="line"><span>    dp[0][0] = 1;</span></span>
<span class="line"><span>    int ok = 1;</span></span>
<span class="line"><span>    // 初始化</span></span>
<span class="line"><span>    for(int i = 1; i &lt;= s1.length(); i++) {</span></span>
<span class="line"><span>        dp[i][0] = dp[i - 1][0] &amp;&amp; s1[i - 1] == s3[i - 1];</span></span>
<span class="line"><span>    }    </span></span>
<span class="line"><span>    for(int i = 1; i &lt;= s2.length(); i++) {</span></span>
<span class="line"><span>        dp[0][i] = dp[0][i - 1] &amp;&amp; s2[i - 1] == s3[i - 1];</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    // dp转化</span></span>
<span class="line"><span>    for(int i = 1; i &lt;= s1.size(); i++) {</span></span>
<span class="line"><span>        for(int j = 1; j &lt;= s2.size() ;j++) {</span></span>
<span class="line"><span>            if(s3[i+j - 1] == s1[i - 1]) {</span></span>
<span class="line"><span>                dp[i][j] = dp[i][j] || dp[i-1][j];</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>            if(s3[i+j - 1] == s2[j - 1]) {</span></span>
<span class="line"><span>                dp[i][j] = dp[i][j] || dp[i][j - 1];</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>            </span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return dp[s1.size()][s2.size()];</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><h2 id="_14-乘积最大子序列" tabindex="-1">14. 乘积最大子序列 <a class="header-anchor" href="#_14-乘积最大子序列" aria-label="Permalink to &quot;14. 乘积最大子序列&quot;">​</a></h2><blockquote><p><strong>题目</strong>: 找出一个序列中乘积最大的连续子序列（至少包含一个数）。<br><strong>解析</strong>: 这里可以借鉴和最大的子序列,但是需要每次保存两个值,一个最大值和最小值,(因为存在负负得正).</p></blockquote><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int maxProduct(vector&lt;int&gt; &amp;nums) {</span></span>
<span class="line"><span>    int premin, premax, ans;</span></span>
<span class="line"><span>    premin = premax = ans = nums[0];</span></span>
<span class="line"><span>    for(int i=1;i&lt;nums.size();i++){</span></span>
<span class="line"><span>        // 每次更新最大最小值,保证负负得正</span></span>
<span class="line"><span>        // 这里使用滚动变量表示dp</span></span>
<span class="line"><span>        int curmax = max(max(premax*nums[i],premin*nums[i]),nums[i]);</span></span>
<span class="line"><span>        int curmin = min(min(premax*nums[i],premin*nums[i]),nums[i]);</span></span>
<span class="line"><span>        premax = curmax;</span></span>
<span class="line"><span>        premin = curmin;</span></span>
<span class="line"><span>        ans = max(curmax, ans);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return ans;</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h2 id="_15-k个数之和" tabindex="-1">15. k个数之和 <a class="header-anchor" href="#_15-k个数之和" aria-label="Permalink to &quot;15. k个数之和&quot;">​</a></h2><blockquote><p i:="" [0,n)=""><strong>题目</strong>: 给定 n 个不同的正整数，整数 k（k &lt;= n）以及一个目标数字 target。在这 n 个数里面找出 k 个数，使得这 k 个数的和等于目标数字，求问有多少种方案？<br><strong>解析</strong>: dp[j][s]比碍事j个数组合s的个数, dp[j][s] += dp[j-1][s-A[i]]</p></blockquote><div class="language-int vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">int</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ans </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> dp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">][</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    dp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">][</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">A.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">k;j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">target;s</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[i];s</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">                dp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[j][s] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> dp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">][s</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[i]];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }   </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ans </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> dp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[k][target];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ans;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h1 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h1><ol><li><a href="https://www.lintcode.com/problem/?tag=dynamic-programming" target="_blank" rel="noreferrer">https://www.lintcode.com/problem/?tag=dynamic-programming</a></li><li><a href="https://www.geeksforgeeks.org/dynamic-programming/" target="_blank" rel="noreferrer">https://www.geeksforgeeks.org/dynamic-programming/</a></li></ol></div></div></main><footer class="VPDocFooter" data-v-39a288b8 data-v-e257564d><!--[--><!--]--><div class="edit-info" data-v-e257564d><div class="edit-link" data-v-e257564d><a class="VPLink link vp-external-link-icon no-icon edit-link-button" href="https://github.com/datawhalechina/daily-interview/edit/master/docs/01-algorithm-basics/algorithm-concepts/dynamic-programming.md" target="_blank" rel="noreferrer" data-v-e257564d><!--[--><span class="vpi-square-pen edit-link-icon" data-v-e257564d></span> 在 GitHub 上编辑此页<!--]--></a></div><!----></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-e257564d><span class="visually-hidden" id="doc-footer-aria-label" data-v-e257564d>Pager</span><div class="pager" data-v-e257564d><a class="VPLink link pager-link prev" href="/daily-interview/01-algorithm-basics/algorithm-concepts/search-algorithms.html" data-v-e257564d><!--[--><span class="desc" data-v-e257564d>Previous page</span><span class="title" data-v-e257564d>搜索算法</span><!--]--></a></div><div class="pager" data-v-e257564d><a class="VPLink link pager-link next" href="/daily-interview/01-algorithm-basics/algorithm-concepts/greedy-algorithms.html" data-v-e257564d><!--[--><span class="desc" data-v-e257564d>Next page</span><span class="title" data-v-e257564d>贪心算法</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"01-algorithm-basics_algorithm-concepts_dynamic-programming.md\":\"DxbDkdYX\",\"01-algorithm-basics_algorithm-concepts_greedy-algorithms.md\":\"SgBmLVy_\",\"01-algorithm-basics_algorithm-concepts_search-algorithms.md\":\"CDp5Dkoe\",\"01-algorithm-basics_algorithm-concepts_sorting-algorithms.md\":\"CUbmf3tc\",\"01-algorithm-basics_data-structures_arrays-and-strings.md\":\"iqnQoB5D\",\"01-algorithm-basics_data-structures_graph.md\":\"CKBDWwVs\",\"01-algorithm-basics_data-structures_linked-lists.md\":\"C7kFfaTk\",\"01-algorithm-basics_data-structures_string.md\":\"B9gI_6Xp\",\"01-algorithm-basics_data-structures_trees-and-graphs.md\":\"CcFSfHFE\",\"01-algorithm-basics_index.md\":\"CrSxq5lm\",\"02-programming-languages_index.md\":\"B9RwcGFJ\",\"02-programming-languages_java_java-fundamentals.md\":\"68qrEBF3\",\"02-programming-languages_javascript_javascript-fundamentals.md\":\"Cc35wYIL\",\"02-programming-languages_javascript_nodejs.md\":\"B_SmVBC0\",\"03-computer-basics_computer-network_http-protocol.md\":\"BN-pb5yl\",\"03-computer-basics_computer-network_network-protocols.md\":\"BW55pT2c\",\"03-computer-basics_database_sql-fundamentals.md\":\"bXmk5i0A\",\"03-computer-basics_index.md\":\"Chn9mHVs\",\"03-computer-basics_mathematics_discrete-mathematics.md\":\"BHS-fBCf\",\"03-computer-basics_mathematics_probability-statistics.md\":\"kKp_X1XJ\",\"03-computer-basics_operating-system_processes-and-threads.md\":\"DXQxTQIj\",\"04-ai-algorithms_computer-vision_cv-fundamentals.md\":\"C5lTwXCW\",\"04-ai-algorithms_computer-vision_object-detection.md\":\"BSz81_wS\",\"04-ai-algorithms_index.md\":\"DRRjDDcM\",\"04-ai-algorithms_llm_llm-interview-questions.md\":\"ANbzCuDw\",\"04-ai-algorithms_machine-learning_ensemble-learning_adaboost.md\":\"YfZqWL7Y\",\"04-ai-algorithms_machine-learning_ensemble-learning_catboost.md\":\"CHQAhdc-\",\"04-ai-algorithms_machine-learning_ensemble-learning_ensemblelearning.md\":\"DDXlhQ_N\",\"04-ai-algorithms_machine-learning_ensemble-learning_lightgbm.md\":\"0iPWbEKj\",\"04-ai-algorithms_machine-learning_ensemble-learning_randomforest.md\":\"BeY7wlhJ\",\"04-ai-algorithms_machine-learning_ensemble-learning_treeembedding.md\":\"BjyUoYJR\",\"04-ai-algorithms_machine-learning_ensemble-learning_xgboost.md\":\"CeIZxe_y\",\"04-ai-algorithms_machine-learning_fundamentals_crf.md\":\"DthcaaPW\",\"04-ai-algorithms_machine-learning_fundamentals_gradient-descent.md\":\"Du-l3H0N\",\"04-ai-algorithms_machine-learning_fundamentals_hmm.md\":\"CU9KduAN\",\"04-ai-algorithms_machine-learning_fundamentals_ml-fundamentals.md\":\"BbGNFoUn\",\"04-ai-algorithms_machine-learning_fundamentals_overfitting-underfitting.md\":\"B16liqGl\",\"04-ai-algorithms_machine-learning_fundamentals_prophet.md\":\"DESh_mGD\",\"04-ai-algorithms_machine-learning_model-evaluation_abtest.md\":\"Blifn6Pd\",\"04-ai-algorithms_machine-learning_model-evaluation_metrics.md\":\"D6kLUBPg\",\"04-ai-algorithms_machine-learning_supervised-learning_decisiontree.md\":\"CY0bKxVn\",\"04-ai-algorithms_machine-learning_supervised-learning_knn.md\":\"B2Co5sMZ\",\"04-ai-algorithms_machine-learning_supervised-learning_linear-logistic-regression.md\":\"BpqVMOdb\",\"04-ai-algorithms_machine-learning_supervised-learning_naivebayes.md\":\"M5r5l8vr\",\"04-ai-algorithms_machine-learning_supervised-learning_svm.md\":\"BqXE3_D4\",\"04-ai-algorithms_machine-learning_unsupervised-learning_kmeans.md\":\"THwCc0EQ\",\"04-ai-algorithms_nlp_deep-learning-models.md\":\"CqW6Dp5Z\",\"04-ai-algorithms_nlp_text-representation.md\":\"BBBKrbGj\",\"04-ai-algorithms_recommendation_collaborative_filtering.md\":\"DHH_Aa4s\",\"04-ai-algorithms_recommendation_deepfm.md\":\"Bpk6C6KJ\",\"04-ai-algorithms_recommendation_gbdt_lr.md\":\"DKZ6n8K_\",\"05-system-design_index.md\":\"CGuMO6eI\",\"06-development-tech_big-data_big-data-interview.md\":\"C4xm9rso\",\"06-development-tech_big-data_hadoop-ecosystem.md\":\"DvHeUeKs\",\"06-development-tech_big-data_index.md\":\"C74taiHu\",\"06-development-tech_big-data_mapreduce.md\":\"Bq5Z56Fi\",\"06-development-tech_frontend_css-advanced.md\":\"0UHwPlN4\",\"06-development-tech_frontend_frontend-frameworks.md\":\"D0P4-vFU\",\"06-development-tech_frontend_html_css.md\":\"Co3mLxtC\",\"06-development-tech_index.md\":\"Bng_Cd0g\",\"07-project-experience_index.md\":\"BFUPIA-M\",\"08-behavioral-interview_index.md\":\"FxbHHFhj\",\"09-interview-tips_index.md\":\"Bw7UVGGi\",\"09-interview-tips_mock-interview.md\":\"CBgRd55b\",\"index.md\":\"BslIEo9M\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"Daily Interview - 面试必看\",\"description\":\"每一个面试者面试之前必看一遍的小面经\",\"base\":\"/daily-interview/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"首页\",\"link\":\"/\"},{\"text\":\"算法基础\",\"link\":\"/01-algorithm-basics/\"},{\"text\":\"编程语言\",\"link\":\"/02-programming-languages/\"},{\"text\":\"计算机基础\",\"link\":\"/03-computer-basics/\"},{\"text\":\"AI算法\",\"link\":\"/04-ai-algorithms/\"},{\"text\":\"系统设计\",\"link\":\"/05-system-design/\"},{\"text\":\"开发技术\",\"link\":\"/06-development-tech/\"},{\"text\":\"项目经验\",\"link\":\"/07-project-experience/\"},{\"text\":\"行为面试\",\"link\":\"/08-behavioral-interview/\"},{\"text\":\"面试技巧\",\"link\":\"/09-interview-tips/\"}],\"sidebar\":{\"/01-algorithm-basics/\":[{\"text\":\"算法基础\",\"items\":[{\"text\":\"概述\",\"link\":\"/01-algorithm-basics/\"},{\"text\":\"数据结构\",\"collapsed\":false,\"items\":[{\"text\":\"数组与字符串\",\"link\":\"/01-algorithm-basics/data-structures/arrays-and-strings\"},{\"text\":\"链表\",\"link\":\"/01-algorithm-basics/data-structures/linked-lists\"},{\"text\":\"树与图\",\"link\":\"/01-algorithm-basics/data-structures/trees-and-graphs\"},{\"text\":\"String\",\"link\":\"/01-algorithm-basics/data-structures/string\"},{\"text\":\"Graph\",\"link\":\"/01-algorithm-basics/data-structures/graph\"}]},{\"text\":\"算法思想\",\"collapsed\":false,\"items\":[{\"text\":\"排序算法\",\"link\":\"/01-algorithm-basics/algorithm-concepts/sorting-algorithms\"},{\"text\":\"搜索算法\",\"link\":\"/01-algorithm-basics/algorithm-concepts/search-algorithms\"},{\"text\":\"动态规划\",\"link\":\"/01-algorithm-basics/algorithm-concepts/dynamic-programming\"},{\"text\":\"贪心算法\",\"link\":\"/01-algorithm-basics/algorithm-concepts/greedy-algorithms\"}]}]}],\"/02-programming-languages/\":[{\"text\":\"编程语言\",\"items\":[{\"text\":\"概述\",\"link\":\"/02-programming-languages/\"},{\"text\":\"Java\",\"collapsed\":false,\"items\":[{\"text\":\"Java基础\",\"link\":\"/02-programming-languages/Java/java-fundamentals\"}]},{\"text\":\"JavaScript\",\"collapsed\":false,\"items\":[{\"text\":\"JavaScript基础\",\"link\":\"/02-programming-languages/JavaScript/javascript-fundamentals\"},{\"text\":\"NodeJS\",\"link\":\"/02-programming-languages/JavaScript/NodeJS\"}]}]}],\"/03-computer-basics/\":[{\"text\":\"计算机基础\",\"items\":[{\"text\":\"概述\",\"link\":\"/03-computer-basics/\"},{\"text\":\"操作系统\",\"collapsed\":false,\"items\":[{\"text\":\"进程与线程\",\"link\":\"/03-computer-basics/operating-system/processes-and-threads\"}]},{\"text\":\"计算机网络\",\"collapsed\":false,\"items\":[{\"text\":\"网络协议\",\"link\":\"/03-computer-basics/computer-network/network-protocols\"},{\"text\":\"HTTP协议\",\"link\":\"/03-computer-basics/computer-network/http-protocol\"}]},{\"text\":\"数据库\",\"collapsed\":false,\"items\":[{\"text\":\"SQL基础\",\"link\":\"/03-computer-basics/database/sql-fundamentals\"}]},{\"text\":\"数学基础\",\"collapsed\":false,\"items\":[{\"text\":\"概率统计\",\"link\":\"/03-computer-basics/mathematics/probability-statistics\"},{\"text\":\"离散数学\",\"link\":\"/03-computer-basics/mathematics/discrete-mathematics\"}]}]}],\"/04-ai-algorithms/\":[{\"text\":\"AI算法\",\"items\":[{\"text\":\"概述\",\"link\":\"/04-ai-algorithms/\"},{\"text\":\"机器学习\",\"collapsed\":false,\"items\":[{\"text\":\"基础理论\",\"collapsed\":false,\"items\":[{\"text\":\"机器学习基础\",\"link\":\"/04-ai-algorithms/machine-learning/fundamentals/ml-fundamentals\"},{\"text\":\"过拟合与欠拟合\",\"link\":\"/04-ai-algorithms/machine-learning/fundamentals/overfitting-underfitting\"},{\"text\":\"梯度下降\",\"link\":\"/04-ai-algorithms/machine-learning/fundamentals/gradient-descent\"},{\"text\":\"HMM\",\"link\":\"/04-ai-algorithms/machine-learning/fundamentals/HMM\"},{\"text\":\"CRF\",\"link\":\"/04-ai-algorithms/machine-learning/fundamentals/CRF\"},{\"text\":\"Prophet\",\"link\":\"/04-ai-algorithms/machine-learning/fundamentals/Prophet\"}]},{\"text\":\"监督学习\",\"collapsed\":false,\"items\":[{\"text\":\"线性回归+逻辑回归\",\"link\":\"/04-ai-algorithms/machine-learning/supervised-learning/linear-logistic-regression\"},{\"text\":\"决策树\",\"link\":\"/04-ai-algorithms/machine-learning/supervised-learning/DecisionTree\"},{\"text\":\"SVM\",\"link\":\"/04-ai-algorithms/machine-learning/supervised-learning/SVM\"},{\"text\":\"朴素贝叶斯\",\"link\":\"/04-ai-algorithms/machine-learning/supervised-learning/NaiveBayes\"},{\"text\":\"kNN\",\"link\":\"/04-ai-algorithms/machine-learning/supervised-learning/kNN\"}]},{\"text\":\"无监督学习\",\"collapsed\":false,\"items\":[{\"text\":\"K-means\",\"link\":\"/04-ai-algorithms/machine-learning/unsupervised-learning/kmeans\"}]},{\"text\":\"集成学习\",\"collapsed\":false,\"items\":[{\"text\":\"集成学习基础\",\"link\":\"/04-ai-algorithms/machine-learning/ensemble-learning/EnsembleLearning\"},{\"text\":\"随机森林\",\"link\":\"/04-ai-algorithms/machine-learning/ensemble-learning/RandomForest\"},{\"text\":\"AdaBoost\",\"link\":\"/04-ai-algorithms/machine-learning/ensemble-learning/Adaboost\"},{\"text\":\"XGBoost\",\"link\":\"/04-ai-algorithms/machine-learning/ensemble-learning/XGBoost\"},{\"text\":\"LightGBM\",\"link\":\"/04-ai-algorithms/machine-learning/ensemble-learning/LightGBM\"},{\"text\":\"CatBoost\",\"link\":\"/04-ai-algorithms/machine-learning/ensemble-learning/Catboost\"},{\"text\":\"Tree Embedding\",\"link\":\"/04-ai-algorithms/machine-learning/ensemble-learning/TreeEmbedding\"}]},{\"text\":\"模型评估\",\"collapsed\":false,\"items\":[{\"text\":\"评估指标\",\"link\":\"/04-ai-algorithms/machine-learning/model-evaluation/metrics\"},{\"text\":\"A/B测试\",\"link\":\"/04-ai-algorithms/machine-learning/model-evaluation/ABTest\"}]}]},{\"text\":\"计算机视觉\",\"collapsed\":false,\"items\":[{\"text\":\"CV基础\",\"link\":\"/04-ai-algorithms/computer-vision/cv-fundamentals\"},{\"text\":\"目标检测\",\"link\":\"/04-ai-algorithms/computer-vision/object-detection\"}]},{\"text\":\"自然语言处理\",\"collapsed\":false,\"items\":[{\"text\":\"文本表征方式\",\"link\":\"/04-ai-algorithms/nlp/text-representation\"},{\"text\":\"深度学习模型\",\"link\":\"/04-ai-algorithms/nlp/deep-learning-models\"}]},{\"text\":\"推荐系统\",\"collapsed\":false,\"items\":[{\"text\":\"协同过滤\",\"link\":\"/04-ai-algorithms/recommendation/collaborative_filtering\"},{\"text\":\"DeepFM\",\"link\":\"/04-ai-algorithms/recommendation/deepfm\"},{\"text\":\"GBDT+LR\",\"link\":\"/04-ai-algorithms/recommendation/gbdt_lr\"}]},{\"text\":\"大语言模型\",\"collapsed\":false,\"items\":[{\"text\":\"LLM面试题\",\"link\":\"/04-ai-algorithms/llm/llm-interview-questions\"}]}]}],\"/05-system-design/\":[{\"text\":\"系统设计\",\"items\":[{\"text\":\"概述\",\"link\":\"/05-system-design/\"}]}],\"/06-development-tech/\":[{\"text\":\"开发技术\",\"items\":[{\"text\":\"概述\",\"link\":\"/06-development-tech/\"},{\"text\":\"前端开发\",\"collapsed\":false,\"items\":[{\"text\":\"HTML & CSS\",\"link\":\"/06-development-tech/frontend/HTML_CSS\"},{\"text\":\"CSS进阶\",\"link\":\"/06-development-tech/frontend/css-advanced\"},{\"text\":\"前端框架\",\"link\":\"/06-development-tech/frontend/frontend-frameworks\"}]},{\"text\":\"大数据\",\"collapsed\":false,\"items\":[{\"text\":\"Hadoop生态\",\"link\":\"/06-development-tech/big-data/hadoop-ecosystem\"},{\"text\":\"MapReduce\",\"link\":\"/06-development-tech/big-data/mapreduce\"},{\"text\":\"大数据面试题\",\"link\":\"/06-development-tech/big-data/big-data-interview\"},{\"text\":\"大数据概述\",\"link\":\"/06-development-tech/big-data/\"}]}]}],\"/07-project-experience/\":[{\"text\":\"项目经验\",\"items\":[{\"text\":\"概述\",\"link\":\"/07-project-experience/\"}]}],\"/08-behavioral-interview/\":[{\"text\":\"行为面试\",\"items\":[{\"text\":\"概述\",\"link\":\"/08-behavioral-interview/\"}]}],\"/09-interview-tips/\":[{\"text\":\"面试技巧\",\"items\":[{\"text\":\"概述\",\"link\":\"/09-interview-tips/\"},{\"text\":\"模拟面试\",\"link\":\"/09-interview-tips/mock-interview\"}]}]},\"search\":{\"provider\":\"local\"},\"editLink\":{\"pattern\":\"https://github.com/datawhalechina/daily-interview/edit/master/docs/:path\",\"text\":\"在 GitHub 上编辑此页\"},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/datawhalechina/daily-interview\"}],\"outline\":{\"level\":[2,3],\"label\":\"页面导航\"}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>